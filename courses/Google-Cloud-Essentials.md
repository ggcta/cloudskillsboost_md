---
id: 621
name: 'Google Cloud Essentials'
type: Course
url: https://www.cloudskillsboost.google/course_templates/621
date: 2025-04-06
datePublished: 2024-12-19
topics:
- Compute Engine
- Google Cloud Services
- Cloud Computing
---

# [Google Cloud Essentials](https://www.cloudskillsboost.google/course_templates/621)

**Description:**

In this introductory-level course, you get hands-on practice with the Google Cloud's fundamental tools and services. Optional videos are provided to provide more context and review for the concepts covered in the labs. Google Cloud Essentials is a recommendeded first course for the Google Cloud learner - you can come in with little or no prior cloud knowledge, and come out with practical experience that you can apply to your first Google Cloud project. From writing Cloud Shell commands and deploying your first virtual machine, to running applications on Kubernetes Engine or with load balancing, Google Cloud Essentials is a prime introduction to the platform's basic features.

## Google Cloud Essentials

Get hands-on practice with the Google Cloud's fundamental tools and services. Optional videos are provided to provide more context and review for the concepts covered in the labs.

### Video - [Google Cloud Essentials](https://www.cloudskillsboost.google/course_templates/621/video/518539)

- [YouTube: Google Cloud Essentials](https://www.youtube.com/watch?v=tac6i6ZcTm0)



### Lab - [A Tour of Google Cloud Hands-on Labs](https://www.cloudskillsboost.google/course_templates/621/labs/518540)

In this first hands-on lab you will access the Google Cloud console and use these basic Google Cloud features: Projects, Resources, IAM Users, Roles, Permissions, and APIs.

- [ ] [A Tour of Google Cloud Hands-on Labs](../labs/A-Tour-of-Google-Cloud-Hands-on-Labs.md)

### Video - [Create a VM on Google Cloud](https://www.cloudskillsboost.google/course_templates/621/video/518541)

- [YouTube: Create a VM on Google Cloud](https://www.youtube.com/watch?v=G-NRWgAjToA)



### Lab - [Create a Virtual Machine](https://www.cloudskillsboost.google/course_templates/621/labs/518542)

This hands-on lab focuses on how to create a Google Compute Engine virtual machine and explores zones, regions, and machine types.

- [ ] [Create a Virtual Machine](../labs/Create-a-Virtual-Machine.md)

### Lab - [Compute Engine: Qwik Start - Windows](https://www.cloudskillsboost.google/course_templates/621/labs/518543)

Google Compute Engine lets you create and run virtual machines on Google infrastructure.  In this lab you create a Windows Server instance in the Google Compute Engine and access it with RDP. Watch a short preview, <A HREF="https://youtu.be/EFPaP20APuw">Launch a Windows Server Instance, GCP Essentials</A>.

- [ ] [Compute Engine: Qwik Start - Windows](../labs/Compute-Engine-Qwik-Start-Windows.md)

### Video - [Compute Engine: Qwik Start - Windows](https://www.cloudskillsboost.google/course_templates/621/video/518544)

- [YouTube: Compute Engine: Qwik Start - Windows](https://www.youtube.com/watch?v=JCtlfde7cDM)

Alright, so we just followed the steps to create a Windows Server virtual machine on Google Compute Engine. Nice work. But what exactly did we do and why? Let's break it down. First, we created a virtual machine instance, which is really just like a regular computer, but it lives in a Google data center. After picking the region and zone, we chose the machine type, which determines things like processing power and memory. Next we configured the boot disk. This is the virtual hard drive for the server. By selecting Windows Server 2022 Data Center as the operating system, this virtual machine will behave just like a physical server running that software. And then we created our instance. And just like a regular computer booting up, we can't actually log in until everything's finished loading. But how do we know when the instance is ready to use? That's where the [gcloud compute instances get-serial-port-output [instance] --zone=ZONE] command comes in. This command, which we ran in Cloud Shell, lets us see behind-the-scenes messages that the server generates as it starts up. It's pretty much a direct line to the server's internal log book. We might see lines of code, status updates, and other technical information scrolling by. What we're really looking for is a specific message "instance set up finish instance is ready to use." Think of this process as similar to checking the lights on a modem or router. We wait for those lights to turn solid green to confirm the internet is ready. Similarly, the message in the serial port output confirms the Windows Server is up and running. And now we can connect to it. All right. So the Windows Server instance is up and running. Now how do we actually get in and start using it. It's like having a brand new house. You need keys to unlock the door. In this case the key is the password. We use the [windows-reset-password] command in Cloud Shell to create a password for the administrator account on the server. This account is like a super user giving us full control over the server. Notice how we specified the username admin in the command. This is the default administrator account name on Windows Server. The command generated a strong unique password for us. And when doing this in the future, make sure you copy and save this password somewhere safe. As it is needed to log in. Finally, we used a Remote Desktop Protocol, or RDP to connect to the server. This lets us interact with the Windows Server desktop as if we were sitting right in front of it. We use the server's external IP address, the username, and the password we set earlier to establish the connection. And that's it. We successful created a Windows Server virtual machine on Google Compute Engine and connected to it remotely. Congratulations! Now we can run windows applications and take advantage of all the benefits of the cloud.

### Video - [Getting Started with Cloud Shell and gcloud](https://www.cloudskillsboost.google/course_templates/621/video/518545)

- [YouTube: Getting Started with Cloud Shell and gcloud](https://www.youtube.com/watch?v=Z7A2bcbWfyc)

[MUSIC PLAYING] SPEAKER: In the fast-paced world of cloud computing, every second counts. Luckily, Cloud Shell and gcloud are here to help, enabling lightning fast development and effortless management of Google Cloud resources. In this video, we'll introduce Cloud Shell and gcloud and demonstrate how they can be used to configure your environment. And then we'll take it a step further and create a virtual machine instance. So once we're in the Google Cloud console, the first thing we're going to do is activate Cloud Shell. But what even is Cloud Shell? Cloud Shell is a browser-based, interactive shell environment for managing and interacting with Google Cloud resources. It's Google Cloud's Command Line Interface, or CLI. And you don't need to install or configure anything. So to activate Cloud Shell, we'll simply click the Activate Cloud Shell button. After we click the button, the Cloud Shell terminal will automatically appear. And then we can use gcloud commands to interact with services through the CLI. Now, one of the many things you can do with gcloud commands is configure your Google Cloud environment. For example, we can set the region and the zone. A region is a specific geographical location where you can run your resources, and each region has one or more zones. Virtual machine instances and persistent disks live in a zone. So let's go ahead and use the gcloud config set command to set our region and our zone. And let's also run config get to make sure the region and zone have been set correctly, which in this case, they have. gcloud commands can also be used to view project details. For example, let's run a command to get info for our project. And the output provides some useful information about our project. One thing to note, if the google-compute-default-region and google-compute-default-zone keys and values are missing from the output, that means a default zone or region hasn't been set. Next, let's set up some environment variables. Environment variables are sort of like shortcuts for your computer. They can store information like project ID and zone so you don't have to type it out every single time. And this is helpful for running scripts or programs because it reduces time and errors. So we'll run a couple commands to create environment variables. And these variables will store our project ID and zone information for fast retrieval later. Let's also run a quick command to verify that the variables have been set properly. This should display the project ID and zone, and it does. The variables have been set. OK, cool. So now comes the fun part. We're going to create a VM instance using gcloud. And this is going to seem really easy because it is. We'll use the gcloud compute instances create command. But let's be patient. The last time I built a computer took me several weeks. And while the VM is spinning up, let's check out the details of this command. gcloud compute allows you to manage your Compute Engine resource in a format that's simpler than the compute engine API. instances create creates a new instance. gcelab2 is the name of the VM. The machine-type flag specifies the machine type as e2-medium. And the zone flag specifies where the VM is created. If you decide not to use the zone flag, the gcloud tool will use your default properties. Other required instance settings like machine type and image are set to default values if not specified in the command. OK, let's return to the Google Cloud console and see how we're doing. Success-- the VM has been created successfully and is up and running. The capabilities of Cloud Shell and gcloud don't stop there. In the next video, we'll filter command line outputs, update a firewall, and view logs. We'll see you there.

### Video - [Cloud Shell and gcloud: Filtering, Updating the Firewall, and Viewing Logs](https://www.cloudskillsboost.google/course_templates/621/video/518546)

- [YouTube: Cloud Shell and gcloud: Filtering, Updating the Firewall, and Viewing Logs](https://www.youtube.com/watch?v=pgkeQfRO5Io)

SPEAKER: Cloud Shell and gcloud are excellent tools for managing Google Cloud resources. And in this demo, we'll show how to filter command line outputs, update firewalls, and view logs. And following the demo, you'll have the opportunity to try it out for yourself in a hands-on lab. Now, when you do start the lab, you could just copy and paste all the commands and call it a day, but we encourage you to actually type out the commands to get a better read on what's happening. So let's start with filters. Using the gcloud config list and component list commands, we can list environment configurations, properties and components. And you can also view your compute instances with gcloud compute instances list. Now, you might not want to see everything, and the good news is you can filter command line outputs. For example, rather than running a compute instances list command that lists every single Compute Engine, we can add a filter. In this case, we're telling gcloud that we only want to list the GCE lab 2 virtual machine. You can do the same thing with other components as well. For example, maybe we want to add a filter to only view firewall rules for the default network. And we can also add a couple different filters to the same command. So we've described how gcloud can be used to configure your environment and create a VM. But can you connect to a VM? Absolutely. With gcloud, this is an easy process. The gcloud compute SSH command provides a wrapper around SSH, which handles things like authentication and mapping instance names to IP addresses. Let's see how this works. First, we'll run a command to connect our VM with SSH. We'll hit Y for Yes to continue, and for the sake of this demo, we'll leave the passphrase blank by hitting Enter and then Enter again. And thanks to some Google Cloud magic happening in the background, we're now connected to the virtual machine. Did you notice how the command prompt changed? The reference before indicates the account being used. And after the at indicates the host machine being accessed. Next, let's install the NGINX web server, which will take a couple of minutes, and then we can brush our hands and pat ourselves on the back. That's really all that needs to be done to connect to a VM instance. To disconnect from SSH and exit the remote shell, we can simply type Exit, and we'll be returned to our project's command prompt. Next, let's walk through how to update the firewall. When using compute resources like virtual machines, it's important to understand firewall rules. So let's run a command to list the firewall rules for this project. After reviewing the list, you'll notice that there are two networks available. The default network is where the virtual machine, GCE Lab 2, is located. Now, if we were to try to access the NGINX service running on the GCE Lab 2 virtual machine, it would fail. This is because it does not have an appropriate firewall rule. The NGINX web server is expecting to communicate on TCP 80. To get communication working, we need to add a tag to the GCE Lab 2 virtual machine and add a firewall rule for HTTP traffic. So we'll go ahead and add a tag and update the firewall rule to allow it. Then we'll list the firewall rules for the project. And let's run the curl command, specifying the location of the virtual machine to verify that communication is possible for the virtual machine. Success-- we get the default nginx output. Finally, let's briefly touch on system logs. Logs are essential to understanding how your project is performing. We'll use the gcloud logging logs list command to list the logs, and let's also filter the command to view just logs that relate to compute resources. Then we'll use the gcloud logging read command to read the logs related to the resource type GCE instance. And if desired, we could also read the logs for a specific virtual machine. In this case, we're displaying the logs for the virtual machine we created earlier, the trusty GCE Lab 2. And with that, you've reached the end of this video. We hope you have a stronger understanding of Cloud Shell and gcloud commands. Time to try it out for yourself in a hands-on lab. Enjoy! [MUSIC PLAYING]

### Lab - [Getting Started with Cloud Shell and gcloud](https://www.cloudskillsboost.google/course_templates/621/labs/518547)

In this hands-on lab you will learn how to connect to computing resources hosted on Google Cloud Platform, and how to use Cloud Shell and Cloud SDK gcloud commands. For a preview, watch the short video <A HREF="https://youtu.be/ZD1zvEyfpLI">Get Started with Cloud Shell, GCP Essentials</A>.

- [ ] [Getting Started with Cloud Shell and gcloud](../labs/Getting-Started-with-Cloud-Shell-and-gcloud.md)

### Lab - [Google Kubernetes Engine: Qwik Start](https://www.cloudskillsboost.google/course_templates/621/labs/518548)

Google Kubernetes Engine provides a managed environment for deploying, managing, and scaling your containerized applications using Google infrastructure.  This hands-on lab shows you how deploy a containerized application with Kubernetes Engine.

- [ ] [Google Kubernetes Engine: Qwik Start](../labs/Google-Kubernetes-Engine-Qwik-Start.md)

### Video - [Google Kubernetes Engine: Qwik Start](https://www.cloudskillsboost.google/course_templates/621/video/518549)

- [YouTube: Google Kubernetes Engine: Qwik Start](https://www.youtube.com/watch?v=fF1SqzejJzY)

SPEAKER: We just went through the steps of deploying an application on Google Kubernetes Engine, or GKE. Let's take a step back and understand what we actually did and why. First, we created a GKE cluster using the gcloud command in Cloud Shell. Think of a cluster as a group of computers working together to run an application. These computers, called nodes, are actually just Compute Engine virtual machines. Once the cluster was up and running, we needed a way to interact with it. That's where authentication comes in. We used another gcloud command to get authentication credentials for the cluster. This allowed us to use the kubectl command, which is the main tool for controlling Kubernetes. John, why don't you give us a quick rundown of kubectl? JOHN: "Koob-ectl?" What on Earth-- SPEAKER: Oh, John, actually, they just told me. It's not pronounced like that. It's "kube-CTL." JOHN: Ku-- kubec-- "kube-CTL?" SPEAKER: Or could it be "koob?" JOHN: "Koom?" SPEAKER: Nope, it's "kube." JOHN: "Kube-CTL." Kubectl. What on Earth is that? The kubectl command is a utility used by administrators to control Kubernetes clusters. SPEAKER: Thanks, John. OK, back to it. So we have the cluster ready, but how do we actually get the application running on it? This is where deployment and services come in. We deployed a simple application called hello-app to the cluster. This application was packaged into a container image, which is like a lightweight, portable version of the application and all its dependencies. We used kubectl to create the deployment, which told Kubernetes to run the container image on the cluster. We then exposed the deployment as a service, which made it accessible from the internet, and GKE automatically created a load balancer to distribute incoming traffic to the application. At this point, we had the application deployed on the cluster. But how do we know it's actually working? This was when we typed the external IP address into the web browser and saw our app saying, "hello, world." I told you it was a simple application. And just to reinforce good practices for managing cloud resources, we used gcloud to delete the cluster, removing all the resources we created. This keeps our cloud resources freed up for others to use and ensures we don't have any unneeded clusters running, which could incur costs. Congratulations! You successfully deployed a containerized application on Google Kubernetes Engine. You learned how to create a cluster, deploy an application, and expose it to the internet. Now you can use this knowledge to run your own applications on GKE.

### Lab - [Set Up Network and Application Load Balancers](https://www.cloudskillsboost.google/course_templates/621/labs/518550)

In this hands-on lab, you set up both Network Load Balancers and Application Load Balancers for your application running in Compute Engine virtual machines.

- [ ] [Set Up Network and Application Load Balancers](../labs/Set-Up-Network-and-Application-Load-Balancers.md)

### Video - [Set Up Network and Application Load Balancers](https://www.cloudskillsboost.google/course_templates/621/video/518551)

- [YouTube: Set Up Network and Application Load Balancers](https://www.youtube.com/watch?v=9JdWJwKRkSQ)

SPEAKER: In this lab, we explored two different ways to distribute traffic to the applications running on Compute Engine, network load balancing and HTTP load balancing. Let's recap what we did and why we did it. First, we created three virtual machines, each running an Apache web server. We also gave them a unique tag, network-lb-tag, which made it easy to apply firewall rules and other configurations to all three instances at once. Using the cURL command with the VM IP addresses, we confirmed that each instance was running and accessible. So the three web servers are running. How do we actually distribute the incoming traffic among them? This is where load balancing comes in. We need a system to efficiently route traffic to destinations without causing congestion. Nobody likes a traffic jam. In this case, we configured a network load balancer which operates at the network level, meaning it makes decisions based on IP addresses and ports. Then we went on a bit of a command spree. We used the gcloud compute addresses create command to reserve a static external IP address specifically for the load balancer that acts as an entry point for all incoming traffic. We used the gcloud compute http-health-checks create command to create a basic HTTP health check that periodically checks the health of the web server instances, as well as the gcloud compute target-pools create command to create a target pool, which we added the three web server instances to by using gcloud compute target-pools add-instances. Or in other words, we set up a health check, created a target pool, and added three web server instances to it. The forwarding rule directs incoming traffic to the target pool. We then tested the network load balancer by repeatedly accessing its external IP address in a web browser. When doing so, we saw that the responses alternated between the three web servers, so we knew the network load balancer was working. Then it was time to create the HTTP load balancer. This type of load balancer operates at the application level, allowing us to route traffic based on URL paths and other HTTP attributes. We created an instance template and a managed instance group to define the backend instances. We also created a health check, a backend service, a URL map, a target HTTP proxy, and a forwarding rule to configure the load balancer, and we confirmed the backend instances were healthy on the load balancing page of the Google Cloud console. But we needed a way to actually test it to make sure it was working as expected, so we accessed the HTTP load balancer by typing its external IP address into a web browser. This is the address we reserved earlier, the public-facing entry point for the application. And the page that loaded in the browser wasn't just a generic "hello world" message. It included the name of the specific instance that served the page, something like lb-backend-group-xxxx. This seemingly simple message is actually key to confirming the balancer is properly routing traffic, distributing the traffic across the instances, and that the instances passed the health check. By completing this lab, we gained hands-on experience with both network load balancers and HTTP load balancers, understanding their key differences and how to configure them on Google Cloud.

## Your Next Steps

### Badge - [Course Badge](https://www.cloudskillsboost.googleNone)
