---
id: 881
name: 'Gemini for Application Developers'
type: Course
url: https://www.cloudskillsboost.google/course_templates/881
date_published: 2024-05-10
topics:
  - Machine Learning
---

# [Gemini for Application Developers](https://www.cloudskillsboost.google/course_templates/881)

**Description:**

In this course, you learn how Gemini, a generative AI-powered collaborator from Google Cloud, helps developers build applications. You learn how to prompt Gemini to explain code, recommend Google Cloud services, and generate code for your applications. Using a hands-on lab, you experience how Gemini improves the application development workflow.

Duet AI was renamed to Gemini, our next-generation model.

**Objectives:**

* Enable Gemini for use with Cloud Code.
* Use Gemini assistance to develop applications.

## Gemini for Application Developers

Learn how to develop an application with help from Gemini.

### Video - [Introducing Gemini for application developers](https://www.cloudskillsboost.google/course_templates/881/video/475233)

* [YouTube: Introducing Gemini for application developers](https://www.youtube.com/watch?v=M6p4PGf8I8c)

This is a developer. Let's learn how developers can use Gemini assistance to develop applications. This developer needs to migrate their code to a different language, and they need to generate code that is tailored to their company's proprietary database. They've been given this direction from their manager with a tight timeline. The developer knows how long exhausting and costly the process of modernizing code can be. But they suddenly remember they've heard about Gemini for Google Cloud and decide to use it to help them write better code fast, debug errors, and create reliable and scalable functionality for their company's website. Let's observe this developer as they use Gemini to simplify the task at hand. First, the developer opens VS code and finds the database connection function that connects their front end website to their back end product database. It's written in C++, and they hope to migrate it to go. We now see the developer open Gemini Code is within VS code and type their conversion request in the chat window. The developer is thrilled to make this request in natural language. By typing in the phrase, convert this function to go and use Cloud SQL, Gemini can understand the context and function that is being referenced, all without leaving the IDE and without having to context switch. Just like that, a converted function appears. The function referenced has now been converted from C++ to go. Our developer is in awe. Gemini converted the code to go and inferred that their Postgres connection needed to be converted to a Cloud SQL database. Because Gemini is trained on Google Cloud specific products and best practices, the developer reviews the generated code and feels confident with this conversion. Next, our developer wants to generate some code by using Gemini. They write a comment and natural language where they explain the function they want to create. After typing out the comment, they click the magic wand, and just like that, Gemini generated the function for them, pulled in appropriate product related API calls, and used functions and methods from their company's SDK and code base. Now our developer is celebrating. They are in awe of all the time, money, resourcing and training hours they've saved without sacrificing quality, and all thanks to Gemini. What's this? They get a new email to start working on a new project that requires them to develop a new product filtering feature to improve customer experience. They are excited to start the next project. Now that they know about Gemini, they open VS code, and instead of writing the function themselves, they simply write a comment in natural language, click on the Magic Wand, and Gemini generates the code for them. Gemini generated code. Here, you can also see that Gemini pulled in very specific methods and functions from their company's code base. This is huge. Typically, writing such code would require them to look up these functions, and that would take a lot of time. The developer then asked Gemini to explain code. Write a test plan and test cases and provide commands to deploy the app to production. Great. Our developer is ready to push their changes to production and ask Gemini how to deploy their application? Success, they got an endpoint, and it worked. Time to celebrate. Our developer quickly generated code deployed and generated tests all without leaving their development environment. With all that time saved, they can now finally get around to finishing their crocheting project. Thanks, Gemini. What will you build?

### Video - [Develop an app with Gemini assistance](https://www.cloudskillsboost.google/course_templates/881/video/475234)

* [YouTube: Develop an app with Gemini assistance](https://www.youtube.com/watch?v=WdF9Xl_XgvQ)

I'm a developer who needs to build and deploy a simple inventory app to Google Cloud. So let's see how I can use Gemini to be more productive. The first thing I notice is that chatting with Gemini is available right here in my local IDE VS Code, which helps reduce context switching. Now I don't know much about Google Cloud but I do know that my team has standardized on containers. So let's see if Gemini can help me figure out how to build and deploy this app in a container. I love that Gemini's response breaks down tooling and platforms for building and deploying containers packed with just enough information for me to be able to make a decision. Cloud run jumps off the page for me in Gemini's response as I don't want to have to manage any infrastructure so let's go with that. Since I don't know cloud run, I'd actually love an example to use to bootstrap and to stay in context as much as possible. Let's see if Gemini can tell me how to get a Cloud Run app running using Google Cloud's IDE extension Cloud Code. We get step-by-step instructions back from Gemini. So let's step through them. [MUSIC] Okay, looks like I got the sample cloned to my environment and I've landed on a readme page that talks about deployment. But first lets see if Gemini can help me quickly understand the contents of the example. I know containers are often built using a Docker file, and I see one here. So let's actually ask Gemini to break it down. [MUSIC] By highlighting the contents of the Docker file, right-clicking, and selecting Explain this. It looks like Gemini gave me a layer by layer breakdown of what is in the Docker file and I see in Gemini's response that our entry point is actually app py. So let's jump over to see that file and see if Gemini can help us understand the application code. Now, I know there are already comments in the example Docker file, but I was still pretty happy with Gemini's explanation and breakdown. So lets see if it can actually shed some light on the hello function in this flask app. Sweet, with Gemini's explanation, I'm able to quickly learn about the code using natural language, including learning about some useful info that's stored in environment variables that my app can access in Cloud Run. Now, I want to start experimenting with adding inventory functionality to this template. And since I know I'll need to write logic to access inventory data, let's ask Gemini for some sample data. I gave Gemini two specifications that it should be JSON with two specific attributes. And not only was Gemini able to generate this data, but I'm also able to take that data from the Gemini interface and add it directly to this new file in the spirit of speeding up my workflow. Now I'm wondering if Gemini can actually help me write a function to access this data directly from my Flask app. Ill start by modifying my import statements in the flask app for what I think we might need. I read that I can use comments to prompt Gemini to generate code for me, so im going to paste in my requirements, highlighting them and select generate code. Ok I think this is what I wanted. The route looks good, were specifying the get method and were returning the inventory data using jsonify. I guess the next thing to do is test the app out. I'll test it locally first. And since there are some Cloud Run environment variables that we're accessing, I actually want to see if there's a local emulator for Cloud Run. Lets ask Gemini. Yep there is. Now can Gemini tell me how to use it? Just what I needed. Gemini responded with a couple of clear steps to follow to deploy to the cloud run local emulator. So lets follow them. Seems to have completed I think the app is now running and exposed on my local machine at port 8080. Let's open this up in a simple browser, and the app is up and running. I can see that the emulator has specified the cloud run environment variable to be local which makes sense. Now let's see if the code that Gemini gave us to return inventory data is working and it looks good to me. The last thing I want to do is figure out how I can actually deploy this to the cloud in cloud run. And now let's follow Gemini's instructions on how to do this. [MUSIC] Looks like I now have a public URL where I can access the app running in the cloud on cloud run and it looks good to me. To recap, with Gemini I was able to be incredibly productive going from idea to deployment in a platform I was not all too familiar with, all in a matter of minutes and without ever leaving my ide.

### Lab - [Develop an app with Gemini](https://www.cloudskillsboost.google/course_templates/881/labs/475235)

In this lab, you'll develop an application using assistance from Gemini within an IDE.

* [ ] [Develop an app with Gemini](../labs/Develop-an-app-with-Gemini.md)

### Video - [Deploying Node.js with Gemini](https://www.cloudskillsboost.google/course_templates/881/video/475236)

* [YouTube: Deploying Node.js with Gemini](https://www.youtube.com/watch?v=E3i-wLNEmiM)

As a software engineer, I like solving problems and creating code. However, the need for boilerplate configurations and remembering deployment commands I don't use often enough, slows me down and takes some of the joy out of the work. Today, we're going to build, test, and deploy a simple Node.js app, and we'll use Gemini Code Assist to help us get up and running quickly, get testing quickly, and deploy our app to the Cloud. We'll be doing this inside of our IDE of choice, which will be VS code for this video. Make sure you have the Google Cloud code extension installed and Gemini enabled in your project to follow along. Let's get started. First things first, we know we're going to need an app.js and a test.js file for running and testing our application. We'll use the terminal to create a folder for our application and those two files to show how Gemini can help us create a project from scratch. We'll be making our app using the express framework. We'll need to install the express and EJS packages. Let's ask Gemini to remind us of the command. After a moment, Gemini gives us information on installing both packages, including a way to only install them for a single project. Since we're just using them for this demo, let's use the save argument to install them locally. Now that those packages are installed, we need to add them to our projects app.js file. Let's use Gemini to make it quick and correct. Gemini provides the code to require the packages and make them available in our file. Let's quickly copy this into our app.js file. Gemini isn't just about chatting, it can also recommend code in line. Let's use this feature to get the recommended boilerplate for initializing the EJS templating engine. All we have to do is write our request in a comment. When we hit Control plus Enter, Gemini will show us its recommendation, sometimes even multiple recommendations. All we have to do is click ''Accept'' and the code is immediately inserted. This is kind of fun. Basically, we can program in pseudocode for these configurations. Let's keep adding some more code, starting with middleware to parse form data. And we'll need to set up the home route. We want a post route called greeting with a parameter for the name of the person to greet. We don't want to forget that the server needs to be started. Finally, let's create a route for greeting that accepts a name parameter. Now that we've got app.js configured, we need to create a package.json file based on it. Let's go back to chat and ask Gemini if it can create one for our existing file. A few moments later, we get a response with the contents for our package.json file. We also get a description of the code so we can understand enough to make any changes. Let's just update the file and copy in that code. In order for our app to work well, we'll need to create our views. Let's create our index and greeting templates inside our views directory. Our index page will be a simple form asking for a name. Our greeting page will use the data it gets from the form to say, hello. Now that we have all our files, we can use NPM start to test that it works. Going to localhost port 3,000 in our browser opens the index page. I'll put in my name and, Hello, Daryl. We've tested that it runs. But what about unit testing? The easier it is to write tests, the more likely they are to get written. Let's see how well Gemini can help us. First, let's make sure our tests will be able to see our app by adding the line module.exports equals app to the end of app.js. Now, let's ask Gemini to generate a unit test for our home route and ensure that the response code is 200. We get a response with all the needed requirements in the code and an explanation of what it does. Not surprisingly, it does what we asked it to do. Let's copy the code into our test.js file we created earlier. From the requirements, it uses the Super Test package, and we'll use the MOCA test framework with that. So let's make sure we have those installed. Now, let's also update our package.json file with our test script and packages in mind. We could ask Gemini how to create our file contents again. But thanks to the previous response we read, we understand that we just need to update the scripts and dependencies sections. We can now run our test with the npm-test command. The test is passing, and we could continue to use Gemini to aid us in writing more tests. Once you have your app working and your tests passing, you'd probably like to know how you can deploy your app to Google Cloud's Cloud Run. Once again, we turn to Gemini to let us know if we can deploy directly and how to do it. We'll run the sample command. When asked, we'll use the US-Central one region and allow unauthenticated invocations, since this is only a test application. After a few minutes, we will be shown a link to where our app is publicly available. And here's the link that we could follow. But we already know what that page looks like. Gemini helps with many different aspects of development so that you can focus on solving more interesting and more difficult problems.

### Quiz - [Quiz](https://www.cloudskillsboost.google/course_templates/881/quizzes/475237)

### Document - [Next Steps](https://www.cloudskillsboost.google/course_templates/881/documents/475238)

## Your Next Steps

### Badge - [Course Badge](https://www.cloudskillsboost.google)
