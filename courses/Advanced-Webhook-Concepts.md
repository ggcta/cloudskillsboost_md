---
id: 1098
name: 'Advanced Webhook Concepts'
type: Course
url: https://www.cloudskillsboost.google/course_templates/1098
date_published: 2024-07-10
topics:
  - Networking
  - Error Handling
---

# [Advanced Webhook Concepts](https://www.cloudskillsboost.google/course_templates/1098)

**Description:**

This course explores advanced technical considerations to optimize Webhook connectivity for comprehensive, end-to-end, Virtual Agent self-service experiences.

**Objectives:**

* Learn how to optimize latency when building Webhooks
* Learn how to design effective error handling and retry mechanisms
* Understand Webhook security, networking, and extra consideration around flexible webhooks.
* Learn how to master debugging techniques for troubleshooting

## Latency Considerations

This module explores the key considerations to optimize for latency when implementing a Webhook in chat and voice environments

### Video - [Latency considerations](https://www.cloudskillsboost.google/course_templates/1098/video/491297)

* [YouTube: Latency considerations](https://www.youtube.com/watch?v=2MpSQu-LOu8)

Welcome to “Advanced Webhook Concepts”. This course builds on top of the “Webhook Fundamentals” and delves deeper into technical considerations such as latency or error handling. This advanced course focuses on optimizing webhook configurations for virtual agents. You'll learn how to: Optimize for latency, Design effective error handling and retry mechanisms, Simulate webhooks for development And master debugging techniques for troubleshooting. A solid understanding of basic webhook concepts and virtual agent development is a prerequisite. This advanced course focuses on optimizing webhook configurations for virtual agents. You'll learn how to Optimize for latency, Design effective error handling and retry mechanisms, And master debugging techniques for troubleshooting. A solid understanding of basic webhook concepts and virtual agent development is a prerequisite. Let’s first learn about latency, and what you can do about it. In this section you’ll learn more about the different things to consider when deploying a webhook in chat versus voice. For example, what are the possible pathways to optimize? And what are the best practices to work with when dealing with long running webhooks? Webhook latency, that is, how long your webhook takes to respond from the time Dialogflow sends its request, depends on multiple factors. The channel (Voice versus chat) is probably the most important distinction, as voice tends to be extremely sensitive to latency while chat is much more tolerant. Once you have a rough idea of what your latency needs to be (as measured in milliseconds), you’ll want to know the different ways you can apply optimizations. These can be: At the infrastructure level (like networking proximity and bandwidth, or compute resources), at the application level (with efficient code and caching), or even at the orchestration level (if you need to call multiple A-P-Is that can be parallelized). Finally, as a mitigation strategy within Dialogflow, you can use Partial Responses to return the information you have to the user. This includes the option of a “please hold” type of message, while your webhook does its work. Let’s first review channel specific considerations. When it comes to Chat Virtual Agent interactions most people are very accustomed to the asynchronous nature of chat. What this means is that you don’t typically expect a reply right away. Even when you know you’re talking to a machine, you won’t be shocked by the need to wait 10 or 20 seconds for a response. This means it’s okay to have your webhooks take a few seconds on a chat agent. However, it’s important to remember that Dialogflow CX has a hard limit of 30 seconds per webhook call. And webhooks are set to a max of 5 seconds by default. This means that you’ll need to adjust the maximum limit to something that makes sense to you with enough legroom. Strive for your webhook to never go over 80% of whatever you set here, in order to avoid unnecessary timeout errors. Voice is different. We typically expect our counterpart to give us an immediate response, human or virtual agent. During the conversation, if the other side is slow to respond, we wonder if they heard us. So we say “are you there?” or “hello?” when talking to humans, or repeat what we said if talking to machine. To avoid this, optimize voice-exposed webhooks to the maximum. And have adequate timeout error handling for whenever the acceptable thresholds are reached. And be sure to adjust your webhook’s timeout values. You can also mitigate the negative effects of latency for voice. If there’s no option other than a few seconds of wait time, use partial responses, like “please wait” messages. Or you can tell the user about results you might already have. The message plays parallel to the webhook’s execution, saving you precious latency time. There are multiple things you can do to optimize for latency. Some of the main ones include: Optimizing for infrastructure, Optimizing the orchestration layer, And optimizing at the application level. Let’s begin with Infrastructure. You want the network latency between Dialogflow and your webhook to be as small as possible. Ideally co-locate your webhook with Dialogflow. For example, if your agent is located on us-central1, your webhook can be a Cloud Function, a Cloud Run service, or a VM on us-central1. Sometimes co-location isn’t an option and your customer requires you to call a web service hosted onprem. This is possible, but ensure the onprem facility is as close to co-located as possible. This means you need to be wise in choosing the closest possible metro facility and the best possible interconnect option for minimal latency. You also want all the equipment, physical or virtual, to be able to handle the load. So make sure any networking equipment (particularly if interconnects and onprem are involved) has enough capacity and won’t be a bottleneck. Make sure the services hosting the actual webhooks (VMs or other pieces of infrastructure) have enough capacity to handle requests as quickly as possible under whatever you consider to be peak load. The Orchestration layer might or might not be relevant to your use case. But it makes sense to discuss it when you have multiple APIs or if your API carries out multiple disconnected task. Sometimes your virtual agent needs to call multiple APIs. In Dialogflow, this can be done one API at a time. It might or might not be okay for your use case to announce results for each API step by step. Other times, your API might take a long time to perform different things that could be parallelized. When one or more of the above situations occur, it helps to have a “wrapper” API. This wrapper can make multiple parallel calls and return the combined results to Dialogflow, speeding up the process. Consider Apigee as an orchestration layer if one is deemed necessary and the customer doesn’t already have software they use for this purpose. Optimizing at the Application level can often be the most impactful thing you can do. Particularly when you have access to the code that will be running for your webhook. There are multiple aspects to this. The first one might seem obvious but is worth mentioning: ensure your code is efficient. Make sure it does not do unnecessary I-O work, that it breaks loops as soon as results are reached, and so on. Cache anything that is slow and can be reused including data that works for multiple users. After fetching external data, store it in a local in-memory cache if it can be reused later. Assign a reasonable time-to-live (or TTL) to it to make sure a new external call is made when it makes sense in order to retrieve fresh data. And also cache data that’s user-specific. Depending on the structure of your agent, you might be hitting a page that calls a webhook multiple times in a conversation. We sometimes see this type of setup in the wild, and it’s easy to optimize. Make sure pages or routes with webhook calls only run if you don’t already have the data you expected from that webhook. You can check whether a given session parameter is null, for example, to go ahead and call the webhook. As an additional consideration, keep in mind that some long-running webhooks can be particularly problematic in voice settings. When you have a long-running process, you ideally want to break it down into multiple calls. This is so you can control the flow and give the caller frequent feedback about the progress, or just to say that they need to wait a little longer. The simplest setup is to have an idempotent webhook. Let’s review an example. First, you call the webhook with a job id parameter, which will initially be null. On receiving the null job id, the webhook initiates a new job, creates a job_id and returns that as a parameter. Now you have a job id. Next, you ask the user to hold, play music or do something else for a few seconds. Then you call the webhook again. This time your job id is there. So the webhook retrieves the job and informs you of its status. If the job status is still IN PROGRESS, inform the user that they need to continue waiting. If the job status includes progress percentage or E-T-A, let the caller know so that they feel things are moving forward. Keep repeating the previous two steps until the job status comes back as COMPLETE. When this happens, the same payload will also contain a results object that you can use to continue with your flow. Partial responses are useful as a way to mitigate latency while running webhooks, particularly over voice. If partial responses are enabled for a webhook call, any queued fulfillments (like ‘agent says’ or ‘custom payload’ for example) will be streamed back to the client immediately. This is different from the default behavior where Dialogflow will wait until the webhook has finished executing and only then return all fulfillments. In order to utilize the advantages that partial responses provide, make sure you enable them on the affected webhooks. And check that your partial response comes in the same conversation turn, before the webhook is called. You want to provide the response and have the user listen to it. Make sure you properly communicate to the user that they will need to hold for a bit. This will increase their tolerance of latency significantly and avoid most potential frustration and abandonment, as long as the wait time is just a few seconds.

### Quiz - [Latency Considerations Quiz](https://www.cloudskillsboost.google/course_templates/1098/quizzes/491298)

## Error Handling

This module explores the available options when encountering unexpected issues with webhook implementations.

### Video - [Error handling](https://www.cloudskillsboost.google/course_templates/1098/video/491299)

* [YouTube: Error handling](https://www.youtube.com/watch?v=IcIkNIVgiq8)

Let’s spend some time now reviewing how to handle errors. In other words, what do we do when the inevitable happens? In this section you’ll explore one of the crucial pieces of the user journey: handling the conversation when the webhook doesn't work properly. There's a few approaches to this problem and in this section we’ll look at them in more depth. "Hope is not a strategy." This wise motto from Google's Site Reliability Engineering (or S-R-E) is spot on, and it applies directly to webhooks. It's crucial to have a proactive plan for webhook failures. Dialogflow CX provides several error event categories that you can prepare for and handle appropriately. By addressing each of these potential error scenarios, you can ensure that your chatbot remains graceful and helpful to users, even when things don't go as planned with your webhook. In the upcoming module, we'll talk more about best practices and strategies for handling these webhook error events effectively. When a webhook encounters an error, how can you gracefully handle the situation? Let's look at some strategies: Retrying the Webhook, Taking an Alternate Path, And handing over to a human agent. Consider the context and the user experience when choosing an error handling strategy. Let’s look at each category separately. When errors like "Webhook Unavailable," "Timeout," or general errors occur, one of the simplest approaches is to just try sending the webhook request again. Often, these types of errors are temporary. Remember, each retry introduces some additional delay in the conversation. Be mindful of this, especially for real-time voice applications. Each retry adds latency, particularly for voice applications, so consider adding messages to acknowledge the delay and ask the user to wait. Set a limit on how many times you retry. You don't want to trap the user in an endless cycle of retries. By carefully managing retries. You can often resolve webhook issues that are transient in nature. Another way to mitigate webhook issues is to take an alternative path, or approach. For example, you can guide the customer to manually take the steps necessary to solve the issue that the webhook would have resolved automatically. If that fails, or if the nature of the issue won’t allow your bot to guide the customer step-by-step, then transfer the call to a human agent.

### Quiz - [Error Handling Quiz](https://www.cloudskillsboost.google/course_templates/1098/quizzes/491300)

## Other Technical Considerations

Exploring other essential technical considerations related to security, network performance and flexible design development when creating Webhooks

### Video - [Other technical considerations](https://www.cloudskillsboost.google/course_templates/1098/video/491301)

* [YouTube: Other technical considerations](https://www.youtube.com/watch?v=dcme8XgIU8g)

Let’s discuss some additional technical considerations around webhooks that you should be aware of. We’ll go over: Webhook Security, where we explore how to secure your webhooks to prevent unauthorized access or data tampering. Webhook Networking, which focuses on configurations and best practices for efficient and reliable webhook communication. And Flexible Webhook Considerations, where we address some of the specific factors you need to keep in mind when using Flexible Webhooks. Let's start by delving into the critical aspects of webhook security. Security is a critical aspect of webhook implementation. Let's examine some of the key areas you must consider to keep your webhooks secure, including: Encryption, Private APIs, and Data exposure. Dialogflow already forces you to have H-T-T-P-S only webhooks when it comes to public endpoints. However, any A-P-I you expose over the internet should also use strong security parameters that aren’t known to have any major vulnerabilities. What can we do to make sure our web communications are as secure as possible? Here are a few things to keep in mind… Prioritize forward secrecy mechanisms. Forward secrecy is a critical security feature that protects past and future communications, even if a long-term private key is compromised. Diffie-Hellman key exchange is a popular forward secrecy mechanism that you should consider using. Utilize robust encryption algorithms and modern hash functions. Encryption algorithms scramble data into an unreadable format, protecting confidentiality. Hash functions generate unique fingerprints of data, ensuring integrity. For encryption, consider using strong algorithms like A-E-S-two-fifty-six-G-C-M Or Cha-cha-twenty-poly-thirteen-oh-five For hash functions, use modern options like: S-H-A-three-eighty-four. Regularly update T-L-S software and apply security patches. Keeping T-L-S software up to date ensures you have the latest security enhancements and vulnerability fixes. Applying security patches promptly addresses newly discovered vulnerabilities and prevents attackers from exploiting them. Dialogflow authenticates webhook calls by default, which means that it checks the identity of the caller before processing their request. This helps to prevent unauthorized access to your webhooks and protect your sensitive data. In addition to the default authentication method, you can also choose to use different authentication methods with custom credentials. This gives you more control over who can access your webhooks and how they are accessed. Dialogflow can also communicate with your A-P-Is via private networking. This means that the communication between Dialogflow and your webhooks is encrypted and cannot be intercepted by unauthorized third parties. Private networking is a good option if you are handling sensitive data or if you want to add an extra layer of security to your webhook interactions. We'll discuss authentication and private networking in more detail in upcoming slides. For now, just keep in mind that Dialogflow provides several ways to secure webhook interactions and that you should choose the option that best meets your needs. One possible mistake is to store webhook-related credentials directly in Dialogflow session parameters. This can be risky because these parameters are included in the webhook payload and aren’t separated from the rest of the request body. This makes them more vulnerable to interception and exposure. If your agent could receive personally identifiable information or P-I-I, then you should at least mark parameters that might contain that type of data as redacted parameters. This ensures the content of those parameters won’t make it to logs from Dialogflow. A more complete approach is to use security profiles with Data Loss Prevention (or D-L-P) to redact sensitive information from webhook payloads. This drastically decreases the chances of leaking P-I-I or other confidential data from your virtual agent.

### Quiz - [Other Technical Considerations Quiz](https://www.cloudskillsboost.google/course_templates/1098/quizzes/491302)

## Webhook Networking

Exploring the key considerations on how Dialogflow CX can reach Webhooks through public, private network endpoints, or serverless private configurations.

### Video - [Webhook networking](https://www.cloudskillsboost.google/course_templates/1098/video/491303)

* [YouTube: Webhook networking](https://www.youtube.com/watch?v=RU_GQHZHurw)

Lastly, let’s discuss some considerations related to webhook networking. There are three main areas to consider around webhook networking: Public and private endpoints, And simple private serverless setup. In this section, we’ll focus on how Dialogflow can reach webhooks over private IPs, whether they are in the cloud or on-prem. First, we’ll look at the default type of webhooks, which use public networking over the internet. We’ll then focus on how Dialogflow can even reach webhooks your service over private IPs, in the cloud or onprem. Finally, we’ll build the simplest and most scalable webhook setup by using Cloud Run and an internal load balancer. Let's get started! By default, Dialogflow communicates with webhooks over the internet. So you must ensure that your webhook server is publicly accessible. It must have a public IP address and be internet accessible. Your webhook server is listening on the correct port. If your server is on a different port, then specify this during configuration. Your webhook server must accept connections from Google IPs. And your webhook server presents a certificate signed by a trusted certificate authority. If not, then upload the certificate chain to Dialogflow CX during configuration. You can't use this setup if your webhook resource is in a VPC-SC perimeter (see private endpoints). If you’re unable to meet any of these requirements, then you’ll have to use private instead of public endpoints for your webhook. The following diagram shows how dialogflow communicates with your webhook over the internet by default. You need a private setup if your web if your webhook resource is in a VPC-SC perimeter. Or if there’s a security or compliance rule that says connectivity should happen within a private address space. VPC Service Controls perimeters define what resources can talk to each other. A perimeter is a collection of resources that are connected by a set of rules. The rules define what resources can communicate with each other, and how they can communicate. VPC Service Controls perimeters can be used to improve security and compliance. For example, you can use a perimeter to prevent resources in one part of your network from talking to resources in another part of your network. You can also use a perimeter to prevent resources from talking to the internet. Set up Service Directory to expose your private network resource to Dialogflow. This resource could be: a virtual machine instance, a Cloud Interconnect address (for onprem or other cloud access), or an internal load balancer (recommended for scalability). This diagram summarizes what private connectivity looks like with the different components it involves, within a VPC-SC perimeter. Setting up private connectivity from Dialogflow to your private network resources can be a daunting task. Particularly because network topologies and setups can vary wildly and can be exceedingly complex. This is the simplest way to set up this connectivity, but it’s also one of the most scalable ways. Refer to the additional resources for more information on private serverless setup. It assumes your webhooks can run on Google Cloud serverless services (Cloud Run and Cloud Functions), which is the most common setup. It uses a fully managed internal load balancer which provides a consistent entry point from Dialogflow with a single private IP address. This setup provides maximum scalability with minimum maintenance and optimized cost. That concludes our in-depth exploration of webhooks! Throughout this course, we've delved into optimal configuration practices, advanced optimization techniques, and the essential technical considerations for effective webhook implementation within your virtual agents. We hope you leave equipped with a solid understanding of how to leverage webhooks to enhance your Dialogflow agents and create more dynamic conversational experiences. Thank you for joining us on this journey!

### Quiz - [Webhook Networking Quiz](https://www.cloudskillsboost.google/course_templates/1098/quizzes/491304)

## Additional Resources

This module includes the list of additional resources that complement the course learning

### Document - [Additional Resources](https://www.cloudskillsboost.google/course_templates/1098/documents/491305)

## Your Next Steps

### Badge - [Course Badge](https://www.cloudskillsboost.google)
