---
id: 390
name: 'Building No-Code Apps with AppSheet: Implementation'
datePublished: 2022-07-13
topics:
- Data Management
- Version Control
- Data Integration
type: Course
url: https://www.cloudskillsboost.google/course_templates/390
---

# [Building No-Code Apps with AppSheet: Implementation](https://www.cloudskillsboost.google/course_templates/390)

**Description:**

This course teaches you how to implement various capabilities that include data organization and management, application security, actions and integrations in your app using AppSheet. The course also includes topics on managing and upgrading your app, improving performance and troubleshooting issues with your app.

**Objectives:**

- Organize and manage the data used by your app.  Add actions, behaviors and automation to your app.
- Control access to your app and its data, and integrate your app  with external services.
- Learn how to improve the performance of your app, manage app versions and upgrade your app.
- Collaborate and author your app with your team, and learn how to troubleshoot problems with your app.

## Introduction

Introduction to the course.

### Video - [Course Introduction](https://www.cloudskillsboost.google/course_templates/390/video/320394)

- [YouTube: Course Introduction](https://www.youtube.com/watch?v=aokTp0Yj2Z0)

[MUSIC PLAYING] HANSEL MIRANDA: When you're familiar with the fundamentals of AppSheet, you can start implementing various capabilities, including data organization and management, application security, and actions and integrations in your app. The implementation process also includes managing and upgrading your app, improving performance, and troubleshooting issues. Hi. I'm Hansel Miranda, a Technical Curriculum Developer at Google Cloud. And I'm here to teach you about these processes and techniques that you can use in your apps with Google Cloud's no-code app development platform AppSheet. This is an intermediate level course designed for app creators who are prepared to implement these AppSheet capabilities in their app. Through a series of video lectures, lab exercises, and quizzes, you'll learn how to organize, manage, and control access to your app's data. Add actions, behaviors, and automation and integrate your app with external services. You will also learn techniques to improve your app's performance and learn how to manage versions and upgrade your app. You will be equipped to author your app with your team and troubleshoot any problems that might arise with the functioning of your app. Let's get started.

## Understanding Data

Organize the data used by your app and add functionality with AppSheet data types and expressions.

### Video - [Organizing data for your app](https://www.cloudskillsboost.google/course_templates/390/video/320395)

- [YouTube: Organizing data for your app](https://www.youtube.com/watch?v=HgEKe9M4aVg)

Hansel: Welcome to the module on understanding data. In this module, we discuss how you can use data elements with AppSheet capabilities to add functionality to your app. We will first discuss some fundamental concepts on working with data entities and the use of keys and tables. We'll review the various data types that are supported by AppSheet and how you can use formulas and expressions to modify the behavior of your app. We also discuss the use of slices to filter the data that app users work with in the app and how you can use AppSheet constraints to implement data validation in your app. Let's start with data entities. AppSheet is a flexible app development platform that enables you to create apps from existing or new data. In this lesson, we discuss some of the basic concepts about data entities to help you organize data and make it easier to manage and use with your apps. We'll first discuss some basic concepts on how data is organized and stored in tables that are used by your app. Data is made up of records. A record is stored as a single row in your spreadsheet or database. An individual record may describe a customer, product, order or other entity. For example, this record provides information about a product such as its product ID, what category the product belongs in, a link to a visual representation of the product and its price. You store each type of record or entity in its own table in the data source. A table is a collection of records of the same type or entity. For example, a customer's table will store records of each customer, and a products table, as shown here, will store records of each product. Think of tables as entities that simulate real things like people, objects or locations. A column is an attribute of a record in the table. Each row in the table will have its own values for each column. For example, in the Products table, each row has different values for some of the shared set of columns in the table: Product ID, Product Name, Product Image and Price. As an app creator, you either use existing data tables or create new ones. As the app is used, data in the tables undergoes changes. Rows in the table may have some of the column values updated. Entire rows may be deleted, or new rows may be added. You also will typically use multiple tables in an app, one for each entity that is managed by the app. When designing the data for your app, you generally follow these steps. First, determine what tables to use. Next, define the set of columns that will store details for each record in each table. Then determine the key column that will provide a unique identity for each row within the table. Finally, determine the relationships between the tables. Let's review these steps in detail. Determining the set of tables that make up your app is the first step in designing your app and its data. The app's functionality will typically drive the design and structure of the data required by the app and determine the set of tables that are needed to implement that functionality. For example, an inventory management app will require data related to products, suppliers, shipping and other information. After you determine the set of tables that will be used by the app, you'll then define the set of columns that will store details for each record in each table. When defining columns, it is important to avoid including multiple columns in the same table that will contain values which are repeated across many rows in the table. You should consider putting those columns in their own separate table and creating a relationship between the two tables. For example, a product's table that contains a row for each product and its information should not also contain product category information because the product category information will be repeated for all products that belong in the same category. Instead, you should have a separate table that stores information about each product category. You'll then create a relationship or a reference from a product in the Products table to its category in the Products Category table. Another design principle when defining your columns is to not store a list of values in a single column for any given row in the table. Consider how you would store a list of all the numbers for a given customer. Because you should not store a list of the ordered numbers in a single column in the customer's table, for each customer row you may initially think of creating multiple columns to store the order numbers, one in each column. This design, however, limits the number of orders a given customer could place via the app. Instead you would create a separate orders table that contains information about each order that is placed through the app. In this table, you would have a customer ID column to indicate which customer a given order belongs to. In effect, you would create a relationship or reference from the Orders table to the Customers table. With this design, a customer can place multiple orders that are represented by rows in the Orders table. After you determine the set of columns in the table, you need to determine which column will contain the key that will provide each row with a unique identity within the table. It is important for the app to uniquely identify each row in the table. To do this, you identify one of the columns in your table as the primary key column that will contain a unique value for each row in the table. Using the Products table as an example, the key column in this example is the product ID column. This column will contain a value that uniquely identifies each product in the table. In the case of products, it may make sense for the key to also be the product ID found on the product label or barcode. It is a general best practice to use an ID column in every table that is used by the app. We will discuss generating keys and unique ID values later in this module. Finally, you need to determine any relationships between the tables that are used in your app. To create a relationship between your tables, when creating your app in AppSheet, use a reference. References are discussed in the Building No-Code Apps with AppSheet Foundations course in this series. Storing related information in separate tables makes it easier to manage. For example, if you need to update information about a product category, you would only need to update a single row in the Product Categories table instead of updating multiple rows of this information while colocated with products in the Products table.

### Video - [Using keys](https://www.cloudskillsboost.google/course_templates/390/video/320396)

- [YouTube: Using keys](https://www.youtube.com/watch?v=PKDgtcqpI6Q)

Person: As mentioned in the previous lesson, it is important for the app to uniquely identify each row in the table. A key uniquely identifies each row in a table. When you add a row to a table, that row must have a unique key value. The row's key value must remain constant for the life of the row. When you update or delete a row through an AppSheet app, the key is used to find the row to update or delete. If two or more rows are inadvertently assigned the same key value, we say the table contains duplicate keys. This is a serious problem. If someone attempts to update or delete one of these rows, the wrong row may be updated or deleted. The column in a table that is designated as the key column must be carefully chosen. Only choose the column that you can guarantee will contain unique values across all rows in the table so that there is no risk of duplicate keys. The product ID column in the products table is a good example of a unique key column. AppSheet supports three types of keys: natural keys, row number keys and system-generated keys. Let's review them in detail. Many tables have a natural key which is a single column or combination of columns that uniquely identifies a row and is part of the entity definition itself. For example, the products table will typically have a product ID column that contains a unique ID for each product or row in the table. A table can also have natural multicolumn keys where two or more columns contain values that, when combined, uniquely identify a row in the table. For example, a table that stores vehicle information may contain a column that stores the license plate number and another column that stores the state in which the vehicle is registered. You can also use natural computed keys by containing table column values using an app formula in AppSheet. The formula must generate a unique expression value that must remain constant for the life of the row. For example, you can have a project management app that uses a table to store project membership information. It contains a column that stores the member ID and a column to store the project ID that the member belongs to. Because a member can belong to one or more projects and a project can contain more than one member, neither of these natural columns can serve as a key for the table. The columns will not contain unique values for the rows in the table. You can instead use a computed key column by concatenating the values in these columns using AppSheet concatenate function. Let's discuss what row number keys are. If you do not specify a key or one cannot be automatically determined, AppSheet will default to using the worksheet row number as the key. The row number is not a good key to use in your app. If entries are moved or deleted or if users add or delete entries simultaneously, the row number for each row will change, and there is no way for AppSheet to uniquely identify the row. When a table does not have a natural key or you want to override AppSheet's automatically selected key column, you can use the AppSheet system to generate a unique key for each row. AppSheet supports two mechanisms to generate random system keys. The unique ID function generates an eight-character unique text value containing letters and numbers. When used with the UUID argument, this function generates a universally unique identifier, UUID, which is a sequence of random digits and letters that can be used as a globally unique identifier. The RandBetween numberLow, numberHigh function generates a pseudorandom numeric value between the low and high number arguments. Let's see how these functions can be used to set a key value for a table. When you add a new table to your app, AppSheet attempts to find a suitable key for the table. AppSheet first examines each worksheet column from left to right looking for a column that contains unique data values. If your worksheet has a good key column, it's a good practice to make it the left most column of your worksheet. If AppSheet finds such a column, it makes that column the key. AppSheet next examines pairs of worksheet columns from left to right looking for a pair of columns that contain unique data values. The two columns don't need to be adjacent. If AppSheet finds such a pair of columns, it will combine the columns to create a computed key. The computed key will be added as a virtual column in the table definition in the app. If AppSheet cannot find a key column using any of these techniques, it will default to using row number as the key. To override AppSheet's automatic key selection and generate a system key, perform the following steps. Open the app in the editor. Navigate to the data section of the navigation menu. Then go to the columns tab in the AppSheet Editor. Expand the table definition that you want to change. Clear the key property checkbox for the existing key column. To override the system-generated key, select the key property for the column that you want to set as the key for the table. Clear the show property for this column if you don't want to display this column in your app. Click the pencil icon to edit the key column settings. Expand the auto compute section to display the initial value setting. Using the Expression Assistant, change the value of this field to unique ID to generate a unique text value for each row in the table. You can also use RandBetween Low, High if you want a numeric key. Click done in the Expression Assistant. Save your changes to the app. The key value for a record must be assigned once when the record is created, and it must remain constant for the life of the record. That is why you must specify the key value in the initial value property and never in the app formula property. The initial value property is computed only once when the record is created. By contrast, the app formula is computed once when the record is created and is recomputed each time the record is updated.

### Video - [AppSheet data types](https://www.cloudskillsboost.google/course_templates/390/video/320397)

- [YouTube: AppSheet data types](https://www.youtube.com/watch?v=xU_HpRc47UA)

Person: In this lesson we discuss the various types of data that can be stored in table columns and how they are used in AppSheet. You can currently choose between 35 data types in AppSheet. These data types can be grouped into 10 categories. They are text, numeric, temporal, change, enumerated, communication, mappable, content, show and other. Let's review the data types that belong in each of these categories. Let's start with text. Text data types come in three forms. Long text: Use the long text type to store one or more lines of text, for example, a description in a column. Name: Use the name text type if you want the name of a person or place to be stored in a column. For example, the name column in a customer's table would be of type name. Text: Use the text type to store a single line of text in a column. Choose numeric data types when the column value can be graphed or used in mathematical operations. Numeric types include the decimal type, which is used to store a number with a fractional component, for example the number 5.5, a real number or a floating point number in a column; the number type, which is used to store a whole number or integer, for example the number 10 in a column; the percent type, which is used to store a percentage value in a example. It is a decimal type with special display characteristics that include the percent symbol. For example, a column of type percent with a value of 0.2 is displayed as 20 percent in the app. The price type is used to store a currency value in a column. For example, the price column in the products table can be of this type. Price is a decimal data type and displays the column's value using a currency symbol that can be configured for the column. The default currency symbol used is the dollar sign. Temporal types include the following data types. Date: Use the date type to store a specific year, month and day in a column. For example an order data or sale date should use this type for the column in a table that saves order or sales information. DateTime: If you want to store a time and date in a column, use the DateTime type. Columns of this type can be used to store a specific year, month, day or a minute and second and are useful to track product shipping and receiving information. The date and time components are separated by a space. Time: Use the time type to store a specific hour, minute and second in a column without regards to the date. Duration: Use the duration type to store a period of time as a number of hours, minutes and seconds in this column. As the name suggests, values of this type can be used in date or time expressions to compute the distance between time values, date values and DateTime values. Dates, times and DateTimes are displayed in AppSheet apps based on the locale of the app user's mobile device when the app is running on the device or the browser's language setting when running the app in a desktop browser. If you want to track changes to the data used by your app, you can use change column types. You can instruct AppSheet to implement a counter, record a time stamp or record a location whenever values in a table's columns change using one of these types: ChangeCounter, ChangeLocation or ChangeTimestamp. For more information on change types, view the documentation on the AppSheet website. For each of these column types, you can optionally define a change trigger. This is a list of columns to watch for changes in their values. Change values: This is a set of values that match the column values that trigger the change. If these options are not specified, the change is triggered when any column is updated with any value in a given row of the table. For example, in a products table you can use a column of type ChangeTimestamp to record the date when the value in the current inventory column for current product row goes to zero. Columns of the enumerated types category are constrained to having a single value or multiple values from a fixed list of allowed values. These types are Color, Enum, EnumList, Progress, Ref and Yes/No. You can use a column of type Color to add a color code to data entries when they are displayed in your app. For example, you could have a status column of type Color in an orders table that uses a color from a list of allowed values to display the current state of an order. Use a column of type Enum to enable a user to select a single value from an allowed list of values when adding or updating data in your app. The EnumList type is identical to the Enum type but allows the user to select multiple values from a list of allowed values. For example, our sample inventory management app includes a form that requests user input to select one or more suppliers from a list of available suppliers of a product. Use the Progress column type to indicate the progress of a data item in a row in the table using Harvey balls. Harvey balls are round idiograms that are used to indicate the degree to which an item meets a particular criterion or can be used to indicate progress of a data item. Using an orders table that stores customer orders as an example, you can use this column to indicate progression of an order from acceptance to fulfillment. Use columns of type Ref to create references or relationships between tables. References are discussed in the foundations course of this series and are documented on the AppSheet website. For example, an order details table is related to an orders table by the order ID column in both tables. You would set the type of the order ID column in the order details table as ref because it relates to the corresponding order ID column in the orders table. The Yes/No column type stores a True/False value in the column in a table. In the column definition, you can customize the display values for this column when the values stored is True or False. For example, the inventory management tab uses a shipping table to track product shipments and uses a Yes/No column to indicate whether an order has been shipped. The actual values displayed for this column are shipped and not shipped. Use the communication column types to launch communications through the app. Email: A value in a column of this type is an email address which enables the app user to send an email by clicking on the additionally. Phone: A value in a column of this type is a phone number that enables the app user to call or send a text message via the app. Note that AppSheet only automatically recognizes phone numbers in North American format. Mappable column types are used to display their values on a map in the app. Address: Columns of this type contain a complete postal or street address. If the address in a table is stored in separate columns, name for the street, city, state, country and zip, AppSheet automatically creates a computed address column that concatenates the values in these columns which can then be shown on a map. LatLong: Columns of this type contain comma-separated latitude and longitude values. XY: Columns of this type contain XY location coordinates that are plotted on a background image. Values in columns of these mappable types are used in map views to plot the location that is determined by the address, latitude and longitude or the XY coordinates on a map in the app. Content column types contains values that are shown as in-line content in the app or open in an external content viewer. Drawing: Use this column type to create a drawing pad in the app that enables a user to capture free-form sketches. Image: Use this column type to display or capture images of type JPG, PNG and GIF. The values may be image URLs or names of files in the source file system of the spreadsheet. Images are captured on the device using the camera or from the local camera row. Thumbnail: This column type is similar to the image type but instructs the app to expect small icons and thumbnails. Thumbnails are captured just like images. Signature: Use this column type to capture a user's signature using a touch-based signature pad, and store it as a small image in the cloud data provider system. The path to the image is stored in the table or sheet. File: Use this column type to include files or PDFs in your app. The value in this column must be the name of a locally accessible file or a publicly accessible URL to the file, for example, in a Google Drive folder. The app opens the content in a hosted web browser. Capture of file is only supported when the app is running in a browser. Video: Use this column type to load publicly accessible URLs to videos or MPEG files in your app. The YouTube embed URL format is also supported. Capture of video is not currently supported through the app. Show column types are empty columns in your table that serve the sole purpose or improving the presentation of data input forms. Show column types are only permitted in form views. There are six categories of show types. Page_Header: Use this type to create a new page within the form. Section_Header: Use this type to create a new section within the same form page. Text: Use this type to show descriptive text in the form. URL: Use this type to display a clickable URL. Image: Use this type to show a static image. Video: Use this type to show an MP4 video. AppSheet supports a category of column types that do not belong in the other categories. These are URL. A column of this type contains a web address. App users can click on the URL link to view the content in a hosted web browser. Users also have the option to open the content in an external native web browser on the device. App: Use the app column type to navigate to a different view in the current app or in another app. The value in a column of type app must be a deep link. A deep link is a specially formatted text value. You construct deep links manually or using AppSheet expressions. For more details on deep links, view the help documentation on the AppSheet website.

### Video - [App column formulas](https://www.cloudskillsboost.google/course_templates/390/video/320398)

- [YouTube: App column formulas](https://www.youtube.com/watch?v=O6PpniKxIMA)

Person: In this lesson, we'll discuss how you can use Appsheet's data management capabilities in your app. Let's first discuss app column formulas and how we can use them in your app. When an app user adds a new record or updates an existing record using a form in the app, you may want calculations to run on the values that were entered or updated and update other columns in the table with the result of the calculation. To implement this capability, you configure an app formula with specific columns in the table used by the app, and that formula is an expression that Appsheet evaluates whenever a user changes a value in a form. Each time such a change occurs in the form, the app formula of every affected column in the row is evaluated, and the column is assigned the result of the formula evaluation. You configure app formulas in the data columns tab in the Appsheet editor. For example, if a table has a price column and a tax column, the tax column might he an app formula, price times 0.5, to compute a 5 percent tax automatically. Appsheet also allows you to specify an initial value for every column. You use an expression to assign an initial or default value for a column when a new record or row is added to the table via the app. The expression can evaluate to a constant or a value that matches the column's data type, or it may be a formula that depends on other columns in the new entry. Its value will be recomputed as the new row is filtered until the user explicitly assigns or overrides the value of the column. At that point, a value has been assigned, and the initial value definition is no longer relevant for the column. An initial value expression acts just like an app formula with two differences. The column is still editable by the user. Once edited, the column is no longer automatically updated with continued recomputation of the expression. Some common examples of initial values include user e-mail, a value of type e-mail that contains the e-mail of the user that is signed into the app; here, a value of type LatLong that contains the latitude and longitude of the current location of the app user's device; now, a value of type DateTime that contains the current date and time.

### Video - [AppSheet expressions](https://www.cloudskillsboost.google/course_templates/390/video/320399)

- [YouTube: AppSheet expressions](https://www.youtube.com/watch?v=2ReYw67FM_0)

Person: You can use expressions in AppSheet to affect your app's behavior and provide users with advanced functionality. An expression is built using a combination of constants, which are numbers, dates and times indexed, values from a table's columns. Use the column name enclosed in square brackets. Operators and functions, expressions are used to calculate new values from existing data. Expressions can be used in app column formulas, initial values for columns, column constraints and to provide values for virtual columns in your app. AppSheet checks all expressions to ensure they are correctly formed and being used in an appropriate manner. For example, if an expression is being used to assign an initial value to a column of type Number, AppSheet checks that the result of the expression is indeed a number. If you're familiar with spreadsheet formulas in Microsoft Excel or Google Sheets, you'll find AppSheet expressions similar in syntax and meaning. There are several different types of expressions that can be used within the app. Use date and time expressions with date, time or duration of values to produce a date, time -- date, time, duration or number value. For example, you can set an initial value for a column in the table to store tomorrow's date using a date expression by adding one to the current date generated by the today function. More details on date and time expressions are documented on the AppSheet website. Use text expressions to produce a text value that is a sequence of letters, numbers, punctuation, spaces or other characters. For example, to send an e-mail to a customer or supply a contact via the app, you can use a text expression to concatenate the first name and last name columns of the contact in the e-mail body. Text, long text and name are data types of type text. To ensure that AppSheet recognizes a raw, textual value in an expression, the value should be enclosed in double quotes. More details on text expressions are documented on the AppSheet website. Use conditional expressions with conditional operators to return a result based on if a condition is TRUE or FALSE. AppSheet conditional operators are if that takes a condition and two results as arguments. Use the IF operator in the conditional expression to return result one if the condition is TRUE, otherwise, result two. For example, if you want to always set a non-negative value for a column, you can use the IF expression shown. IFS that takes pairs of condition and result arguments, use the IFS operator to return result one if condition one is true. Else, return result two if condition two is TRUE and so on until one of the conditions evaluated left to right is TRUE. For example, to return a string result based on the value in a column that stores a due date, you can use the IFS operator with conditions that compare the value in the column with the result of the today function. SWITCH, that takes an expression, pairs our value and results and a default result as arguments. Use the SWITCH operator to return result one if the expression evaluates to value one, as return result two if the expression evaluates to value two and so on. If none of the values match the expression, then the default result is returned. For example, using AppSheet's built-in functions to day and month, you can use the SWITCH expression to convert the current month number to the month name. Use math expressions with operators, plus, minus, multiply and divide, to add, subtract, multiply and divide numeric values to generate values that are of the basic numeric types, number or decimal. Math functions can also be used in math expressions. For example, to compute the tax amount on a product's price using a fixed percentage, you use a math expression to multiply the value in the price column by the percentage amount. Then, to compute the total price of a product for display in the app, you can use another math expression to add the values in the price and tax columns of the product's table. We'll review AppSheet's built-in functions later in this lesson. To learn more about math expressions, view the documentation on the AppSheet website. Use Yes/No expressions that produce a result which is either TRUE, Yes, or FALSE, No. These expressions are generally used in AppSheet where you need a conditional statement. For example, you can use a Yes/No expression in a short IF column constraint to only display the column's value if it is non-empty. These expressions use operators that return a TRUE or FALSE result. The operators are comparison operators, composition operators and other operators. Use comparison operators that compare two parameters to generate a TRUE or a FALSE result depending on whether the comparison is valid. For example, the expression five greater than two is valid, but the expression five greater than hello is not valid. Use composition operators AND/OR and NOT to wrap multiple conditions but compare values or expressions. For example, the expression AND, five greater than two, two greater than one, returns TRUE since both the conditions are TRUE. If any of the conditions are FALSE, the expression result is FALSE. AppSheet supports other operators that check if an expression is empty, ISBLANK, if a text value is part of another text value, CONTAINS, and if a value is contained in a list IN. To learn more about Yes/No expressions, view the documentation on the AppSheet website. A list is a collection of zero or more values, each of the same data type, for example, a list of numbers, a list of names, a list of e-mail addresses, a list of rows, et cetera, are all lists in AppSheet. You use a list expression to create a list or create a result of any type using one or more lists. To learn more about list expressions, view the documentation on the AppSheet website. You can construct lists in the following ways: from raw values and expressions; from the value in a table's column; using functions; by list addition and subtraction; and by column dereferencing. To construct a list from raw data values, enclose the values in curly braces. The list must have at least one value, and multiple values must be separated by comma. All values within the list must be of the same data type. Note that expressions within the curly braces are not evaluated and should not be used. To construct a list from an expression, use the LIST function with a combination of raw values, column values and expressions. For example, using the LIST function with text parameters, apple, banana, cherry, produces a list of text values. The LIST function with the names of columns, mobile phone, office phone, home phone in square brackets as parameters produces a list of phone numbers from three column values of the current row in the table. Using the LIST function without any parameters produces an empty list. To construct a list from the values of a column in the table, use the name of the table followed by the name of the column in square brackets. This is called a table-column reference. For example, products, product name produces a list of all values from the product name column from the rows in the products table. Note that a table-column reference to a column of type list or [Indistinct] list will produce a list of lists. To flatten a list of lists into a single list composed of the values of the component list, wrap the table-column reference with the split function. For example, split employees' vacation dates, comma, produces a list of all employee vacation dates separated by comma from the vacation dates column in the employees table. You can use LIST functions to construct lists. There are many such functions that are supported by AppSheet that produce a list. We've already seen the LIST and SPLIT functions earlier. Another such function is SELECT. You can use this function to return a list of column values from a table. For a complete list of LIST functions and their usage syntax, refer to the documentation on the AppSheet website. You can combine the contents of two lists to construct a new list using the List add operator. The items in the resulting list will be in the order they occurred in the original list, and duplicate entries are preserved. The example shown produces a list of number values, one, two, three, two, three, four. The second example produces a list of all employee office and home phone numbers. Note that the list resulting from list addition will adopt the data type of the list on the left-hand side. If the list on the right-hand side is of a different data type, this may change how the values taken from it are interpreted. Use the list-subtract operator to produce a new list with the values of the list on the left-hand side that are not present in the list on the right-hand side. The values of the resulting list will be in the order they occurred in the original list on the left-hand side, and duplicate entries will be omitted from the result. The first example produces a list of one number type value, the number one. The second example produces a list of text values, Bob and Mary. In this example, in addition to the requested removal of Alice, note that the duplicate occurrence of Bob was also omitted from the result. You can also generate a list when using a ref column by dereferencing the related or reverse-referenced list column and specifying the column name whose values make up the resultant list. For example, the expression Related Orders, Order Date will generate a list of order date column values from the rows identified by the list in the related orders column. AppSheet supports a range of other types of expressions that are mainly functions that don't fit in the other types of expressions discussed earlier. These functions enable you to work with hyperlinks and URLs, current app and user context, map and distance objects and unique identifiers and text icons. More details about these functions are documented on the AppSheet website. When you're writing expressions in the App Editor, you can use AppSheet's Expression Assistant to help construct exactly what you need. You can build and test simple and complex expressions using this tool, which is available in the AppSheet Editor anywhere you are able to enter an expression. The Expression Assistant tool is denoted by a flask icon next to the input field. To open the Expression Assistant, you click the flask icon next to the a field to toggle to the expression format. Click in the expression field where indicated with an equals sign. The equals sign indicates that the value is equal to the expression being evaluated. The Expression Assistant dialogue contains a field to enter the expression. The green check mark indicates that your expression's syntax is correct. Examples for all available expression types and functions are also provided in the assistant. To build your expression, you can use the Insert link to append an element to the expression field in the assistant. Finally, you can use the test button to see if your expression works as expected.

### Video - [Slices](https://www.cloudskillsboost.google/course_templates/390/video/320400)

- [YouTube: Slices](https://www.youtube.com/watch?v=5hmeD8DeqBE)

Person: A slice is a subset of the rows, columns and actions of the table that is used in your app. Instead of using the contents of the entire table for some views in your app, you can use slices to include a subset of the rows, columns and actions. For example, a slice could be used to display a view of a subset of rows from an orders table that have a status of pending. We discuss actions in more details in the next module in this course. To define a slice, you specify the following: the slice name, the underlying table, the subset of rows from the table, the subset of columns from the table, the subset of actions from the table and permission settings for adds, deletes and updates. The slice name, underlying table and permission settings are required while you typically subset only the rows or only the columns and actions as needed. Slices are most useful when you want to create a UX view of part of a table. For example consider a table that contains a list of products with your current and minimum inventory quantities. To view only those products whose inventory levels are below their thresholds you can create a slice that only includes these product rows and a subset of columns from the table. Let's review the process to create such a slice in the AppSheet editor. To create a slice, navigate to the data slices tab in the AppSheet editor. To create a new slice, click on new slice. In the new slice configuration form, provide the slice name, the underlying source table, the row filter condition that when true selects a subset of rows. In our example, we use a conditional expression to compare the values in the current inventory and minimum acceptable inventory columns of the products table. This condition uses a yes/no expression. Rows that satisfy the condition are part of the slice. Those that fail the condition are excluded. A custom set of columns to include in the slice: You can also select all columns to include all the table columns in the slice. Note that when custom is select AppSheet may automatically add back columns that are required for the slice to operate correctly. Usually this occurs with key columns that have been unintentionally excluded from the slice. A subset of the actions defined on the underlying table: Using the app editor you can change the default auto actions list to be an explicit list of actions from the underlying table. We discuss actions in the next module in this course. Update moderate permission settings that allow the app user to add, update or delete data in the slice. You can also set the permissions to read-only so that the data in the slice can only be used for displaying in the app. To preview the rows and/or columns of data in the slice, you can click view data. Here is a sample of the data read from the products table. Once you create a slice for your app, you still need to use it in a UX view. To use a slice in a view, you create the view from the UX views tab in the editor. From the views tab, you can create a new view or modify existing views. When creating the view, provide the name and specify the slice as a source of data for the view. Like other view definitions, you configure the view type and other options for the view.

### Video - [Constraints](https://www.cloudskillsboost.google/course_templates/390/video/320401)

- [YouTube: Constraints](https://www.youtube.com/watch?v=BJXHU7HuQG8)

Person: In this lesson we discuss how you can use different constraints to control the display and usage of column data and to implement data validation in AppSheet. Let's first discuss AppSheet constraints. The Show_If constraint is one such constraint that you can use in your app. To implement this constraint, you use the Show property in the AppSheet editor. This property controls the visibility of a column in the app. You can dynamically show or hide the column by configuring a Show_If expression for the column. For example, you may want to only show the Quantity Shipped column from a shipping table if the product has actually been shipped, as indicated by a shipped Yes/No column. To build the Show_If constraint expression using the Expression Assistant, follow these steps. Select the Columns tab in the Expression Assistant. Click Insert to insert the Shipped column in the Expression Edit field. Select the Yes/No tab in the Expression Assistant. Click Insert to insert the value true in the Expression field. Edit the expression, and type the equals comparison operator in between the Shipped column and the true value. This creates a Yes/No expression, which satisfies the requirement of the Show_If constraint. This checks if the value in the Shipped column has the value true. Saving the expression in the assistant adds the expression to the Show Column property. Now, when entering shipping information for a product in the app, the Quantity Shipped field is not displayed unless the product has been marked as shipped. The Show_If column constraint is applied any time the column itself is displayed. The column constraint is not applied to the column value when used in an expression. Show_If conditions can be enabled only for form views or for all views in the app. You can control this behavior using the Apply Show_If Constraints Universally setting under the UX Options tab in the AppSheet editor. The Editable_If constraint is another type of constraint that you can use in your app. The Editable constraint enables you to allow updates to a column's value either by the app user via the app or by app formulas. You may have certain columns in a table that are used to contain static values or are used to control app logic. These columns are typically not meant to be edited and can be configured as such. You can also apply a Yes/No expression to determine if the column is editable or not.

### Video - [Data validation](https://www.cloudskillsboost.google/course_templates/390/video/320402)

- [YouTube: Data validation](https://www.youtube.com/watch?v=pvEEg_RzO9Q)

Person: Let's discuss how you can implement data validation for your app in AppSheet. To implement data validation for the values in table columns, you'd define a Valid_If column constraint for the column. To define a Valid_If expression for a column, you use the Expression Assistant in the AppSheet Editor. As an example, let's configure a sample app to validate that any number that is entered for the quantity shipped column in the shipping table is greater than zero and less than or equal to 500. To build the expression, follow these steps. This constraint expects a yes/no or a list expression. In the Expression Assistant, select the yes/no tab. Scroll the examples and insert the "and" composition operator to leave the default "and" conditions in the expression field. Select the columns tab and insert the "this" column. This represents the value in the current column which is what we need to be evaluated. Type the greater than zero condition followed by a comma. Insert the "this" column again and type the less than or equal to 500 condition. Saving the expression populates the Valid_If constraint for the column. You can also customize the error message of the value entered by the app user while it's the constraint. Entering and saving a row with a value greater than 500 in the quantity shipped column in the app now generates the error message. For more information on the Valid_If constraints, view the documentation on the AppSheet website. Dependent drop-down lists are a common design pattern in apps that capture input. For example, consider a sales lead tracking app that first asks for a sales region, America, Asia, Europe, and then for a country within that region. The app uses a separate regions lookup table with two columns, region and country, which serve to list the allowed combinations of regions and countries. The region column in the app has a regular Valid_If constraint, Regions(Region). Therefore, when a new entry is being added, the input for this column shows three choices: America, Asia and Europe. Likewise, the country column specifies a similar Valid_If constraint, Regions(Country). However, because it follows the region column and because both specify columns from the same lookup table regions, AppSheet recognizes the intent and implements a dependent drop-down list. This normally requires relatively complex logic, but AppSheet tries to make it simple without requiring the app creator to use complex expressions. You can also configure a column to be required or not before a user can save a data row in a table via the app. To implement this, simply enable the Require? option in the data validity section of the column configuration form in the AppSheet editor. You can also optionally configure a Required_If yes/no expression for the column using the Expression Assistant. The column value will be required if the expression evaluates to true. Both Google Sheets and Microsoft Excel support a built-in mechanism called data validation rules. Data validation rules allow you to constrain the values that can be entered into a worksheet cell. You define one or more data validation rules for your worksheet. Typically, you define a separate data validation rule for each column in your worksheet where you need to constrain user-entered values. The example shows a data validation rule for the User Roles sheet in an app that uses an enumerated list of valid role settings. When you create an app from a worksheet with data validation rules, AppSheet automatically detects these rules and applies them to your app. Drop-downs are automatically created in your app from the data validation rules. This ensures that data values entered through your app conform to the same rules as data values entered directly into your worksheet. Note that AppSheet does not automatically detect any changes that you make to the worksheet data validation rules. Each time a rule is modified, you must manually regenerate the corresponding AppSheet table. After the table structure is regenerated or added to your app, AppSheet detects the changes and updates the app accordingly. For more details on using worksheet data validation rules, view the documentation on the AppSheet website.

### Video - [Lab: Working with Data in AppSheet](https://www.cloudskillsboost.google/course_templates/390/video/320403)

- [YouTube: Lab: Working with Data in AppSheet](https://www.youtube.com/watch?v=De50GnqqKbo)

PERSON: We now invite you to take a lab on the topics discussed in this module. In this lab, you learn how to configure initial values and app column formulas in your app, use different AppSheet column types, create partial views of the data in your app with data slices, implement data validation, use constraints to control the display of column data in your app. To do this lab, click the link provided on the learning platform.

### Lab - [Working with Data in AppSheet](https://www.cloudskillsboost.google/course_templates/390/labs/320404)

In this lab, you'll use various data features that are provided by AppSheet in your app.

- [ ] [Working with Data in AppSheet](../labs/Working-with-Data-in-AppSheet.md)

### Quiz - [Quiz](https://www.cloudskillsboost.google/course_templates/390/quizzes/320405)

#### Quiz 1.

> [!important]
> **What are some AppSheet data types available for you to use in your app? Select four.**
>
> - [ ] Name
> - [ ] ChangeTimestamp
> - [ ] Address
> - [ ] GPS
> - [ ] Price

#### Quiz 2.

> [!important]
> **A key is a column whose value provides a unique identity for each row in the table. What types of keys are used in tables in AppSheet apps? Select three.**
>
> - [ ] Row number keys
> - [ ] Natural keys
> - [ ] Artificial keys
> - [ ] System generated keys

#### Quiz 3.

> [!important]
> **What is a slice in AppSheet?**
>
> - [ ] A slice is a subset of the rows of a table that is used in an app.
> - [ ] A slice is a subset of the columns of a table that is used in an app.
> - [ ] A slice is a subset of the rows, columns, and actions of a table that is used in an app.

#### Quiz 4.

> [!important]
> **What are some characteristics of app column formulas and initial value expressions in AppSheet? Select 3.**
>
> - [ ] An app user can edit a table column's value with an initial value expression.
> - [ ] An app user can edit the value of a table column that has an app column formula defined.
> - [ ] The initial value expression of a table column is not re-computed after that column's value is updated by the app user.
> - [ ] An app column formula is used to update the value in a table column whenever a change is made to that table's data via a form in the app.

#### Quiz 5.

> [!important]
> **What steps must you take when designing the data for your app? Select three.**
>
> - [ ] Determine the tables to use and the column structure that will store data in each table.
> - [ ] Determine the relationships between the tables in your app.
> - [ ] Determine how the data in the tables should be displayed in your app.
> - [ ] Determine the key column that will provide a unique identity for each row in the table.

### Video - [Module Review](https://www.cloudskillsboost.google/course_templates/390/video/320406)

- [YouTube: Module Review](https://www.youtube.com/watch?v=MGyYm1QnV2s)

PERSON: Congratulations on completing this module on using data in AppSheet. Let's do a quick review. In this module, you learned about data entities and how to organize the data used by your app. We learned about the various data types used in AppSheet and how they can be used to store and display data in your app. You also learned how to use slices, app column formulas, and AppSheet expressions to add functionality and use data more effectively in your app. Finally, we discussed how to define and use column constraints to control the display and validity of data in your app.

## Adding Behaviors to Your App

Add functionality to your app with AppSheet actions and behaviors.

### Video - [Actions](https://www.cloudskillsboost.google/course_templates/390/video/320407)

- [YouTube: Actions](https://www.youtube.com/watch?v=AE69iLX37Ro)

Hansel: Now that you understand how to structure and manage your app's data, let's explore how to manage the end user's interaction with your app. In this module, we discuss how you can add behaviors to your app using AppSheet actions. With AppSheet, you can control how users interact with your app and how your app behaves by creating different types of actions. As an app creator, you create one or more actions for your app. In addition to the actions that you create, AppSheet automatically generates system actions and applies these actions to your app based on the structure of the data used by the app. In this module, we discuss how you can use AppSheet actions to facilitate user interaction with the app and its data. We also review some advanced features that you can add to your app to provide extra UI capabilities. In this module we will discuss AppSheet actions, AppSheet automation, offline sync, advanced UI behaviors and how to customize input forms. You will also do a couple of labs in this module, so let's get started. In this video, we'll first review what actions are and review actions for app navigation and data changes before discussing actions for external communication and composite actions. So, what are actions? In AppSheet an action is an operation that changes the state or navigational behavior of the app. There are currently four categories of actions. App navigation actions, use this type of action to navigate the user to a new view within the app to or a view in another app. Data change actions, use this type of action to add, delete or update data that is used by the app. External communication actions, use this type of action to initiate communication with an external service. Composition or grouping actions, use this type of action to group existing actions in your app. Some actions are automatically created by AppSheet that you, the app creator, can later modify. These actions are system defined and known as system actions. System actions are created by AppSheet based on the column structure for table that is used by your app. They represent the default behavior of the app. The most common examples of system actions are per column system actions. An example of this type of action is the email system action that is automatically created by AppSheet for any table with a column of type email. This is displayed as en email envelope icon that is shown in an app view. When users click on it, the email app on the user's device is launched. Similarly, any lat-long column in the table has a system generated view map action created for the table. When viewed in the app, each row from this table has a map pin icon next to it. When users click on the icon, it opens a map that shows the location of the column's value plotted on the map. In most apps, there is no reason to ever modify system actions. They are designed to work correctly without the app creator's intervention. However, there are instances that the app creator may want to control when these actions can be invoked or modify the action's display options. For example, in some cases the app should not enable calling phone numbers or you may want to change the icon shown for certain actions, et cetera. You can show or hide system actions using the show action bar option in the view options section of review definition and you can also add or remove actions that are shown in the bar. System actions can be edited with some limitations. Only some of the properties of the action can be changed. Specifically the appearance properties and the behavior properties that include the condition that determines when the action can be shown. If the table's column structure changes, the system will automatically delete and recreate system actions. Any changes to the system actions made by the app creator will be lost and must be reimplemented. AppSheet supports various types of actions. These action types are categorized by app navigation, data changes, external communication and composition. We will review each of these action types in detail in the next set of videos. To create an action, navigate to the actions tab in the AppSheet editor and click add new action. In the new action form, configure the action by providing the action name, the table to which the action applies, the type of action to perform, for example a data action. Additional configuration based on the type of action. For example, the specified columns to set for data expressions or values. Appearance options that include the action display name, icon and display prominence. You can also specify the following behaviors for an action. A condition to apply the action to only certain rows of the table that satisfy the condition. Whether the confirmation is required from the app user before applying the action. A message that is displayed to the user reviews a confirmation is required.

### Video - [Actions for app navigation](https://www.cloudskillsboost.google/course_templates/390/video/320408)

- [YouTube: Actions for app navigation](https://www.youtube.com/watch?v=o09BymaubS8)

Person: In this video we discuss the AppSheet actions that you can use in your app to navigate the app user to different views in the current app or to another app. Let's review the app navigation actions that are currently supported by AppSheet. The action type app: copy this row and edit the copy creates a copy of the current data row in the table that is being used in the app and opens the copy in a form view. For example, our sample inventory app displays shipment transactions. To accommodate additional shipments for the same product, you could use this action type to duplicate an existing transaction and modify the shipment quantity. To implement this functionality we follow these steps. Create and name the action: copy shipment. Set the table to which this action will apply: shipping. Set the action type: app: copy this row and edit the copy. Then, in the appearance section, set the action icon, the display prominence, display overlay. Then, enable the needs confirmation option and set the confirmation message prompt that the app user sees when the action is invoked. Now when viewing a shipment transaction in the app, the user clicks the copy shipment action and confirms the copy of the shipment transaction by clicking copy shipment. After confirmation, the shipment form is displayed with the column values copied from the original shipping transaction. The user then edits the shipping information and saves the form. When the app syncs with the data source, a second shipment transaction is added to the table. The action type app: export this view to a CSV file downloads the rows in the current view of a table to a CSV file. Note that the action only works for an app that requires user sign-in and is running in a desktop browser. You may want the app user to be able to download data from certain views in the app, for example, to keep a record of certain types of transactions. When configuring this action, you must specify the locale of the CSV row data that is exported by either selecting one of the supported locales or specifying an expression that evaluates to a locale identifier of one of the supported locales, for example, in US. More details on this action type can be found in the documentation on the AppSheet website. The action type app: go to another AppSheet app opens an AppSheet app that is different from the current app. You must configure this action with a deep link to the target app. The target can contain an expression to compute the deep link at the time the action is triggered. You can use the LINKTOAPP function to construct the deep link to the target app. The action type app: go to another view within this app takes the user to another view in the current app. You must configure this action with a deep link to the target view. The target can contain an expression that uses the LINKTOVIEW function to compute the deep link at the time the action is triggered. Let's create an action that navigates a user from one view to another in the app. In the example shown, we have a list of products with current inventory levels stored in a table. Let's add an action that enables the app user to create a shipping request for products that have a current inventory level above 10 units. To do this, first click add new action to create the action. Then, configure the action by setting the following: action name, ship; for a record of this table, choose the products table; in the do this field, select app: go to another view within this app; for the target view, we use the LINKTOFORM function that shipping outbound form which is the name of a form view that was previously created in the app. We use the Expression Assistant to build a deep link using the LINKTOFORM function. The LINKTOFORM function constructs a deep link to the form view with the value of the specified column pre-filled in the form. In the appearance section of the action configuration, select an appropriate icon for the action. Set the prominence to display overlay so that the action icon is displayed in the action bar in the app. Next, we set the condition for this action to be shown in the app. We want the app user to be able to use this action only on those products with a current inventory level above 10 units. Use the Expression Assistant again to set the condition using a Yes/No expression. After saving these changes to the app, you can now see the new ship action icon displayed only for those rows in the products table that satisfy the action's condition. Clicking on the ship icon for a specific product navigates the app user to the configured form view with the product details automatically populated. In this form view, the app user can now enter the required information to create a shipping entry for the product. The action type app: import a CSV file for this view uploads the rows in a CSV file to the current view. Note that this action only works when the app is running in a desktop browser. You can use the import action type to add one or more new records to an AppSheet table or update one or more existing records in an AppSheet table. More details on this action type can be found in the documentation on the AppSheet website. The action type app: open a form to add a new row to this table opens a form view that enables users to add a new row to the current table. Note that this action differs from the previously discussed action app: go to another view within this app in that this action can only be used to open a form view for the current table. You can use this type of action to customize the action icon and its display prominence and appropriate app views instead of using the system add action. To hide the system add action in such scenarios, you set its display prominence to do not display in the appearance section of the action definition form. The action type app: open a form to edit this row opens the form that enables users to edit a row in the current table. The actions to open a form to add a new row or edit the current row are similar to their system action cousins, add and edit. You can create these actions in addition to the system actions when you need to display them differently in the app. For example, the suppliers table in our sample inventory management app contains a detailed view of a supplier row with a default system edit action. In addition to this default edit action, we want the app user to directly edit a supplier row from the table view that displays the list of suppliers. To implement this, we create a new action with a name edit suppliers. Set the table to which this action applies, suppliers. Set the action type, app: open a form to edit this row. In the appearance action, we configure the action icon, the prominence of the icon so that it displays in line with the row, the attach to column, supplier name that the icon is attached to when displayed in line in the app. Finally, since we want to display this action only in the supplier table list view, we set only if this condition is true, a Yes/No expression, using the built in context function that returns true if the current view in the app is the supplier table view. For details on the context function, view the documentation on the AppSheet website. As you can see in the live app preview, we now have the edit action displayed in line with each row in the supplier table view. By clicking the edit icon, the app user can edit the supplier row directly using the supplier form. By clicking the supplier name, the app user navigates the supplier detail view. In this view, the app user can click the system edit action to edit the supplier using the same supplier form. Note that there's a new beta quick edit feature in AppSheet that if enabled for a table view, allows the app user to edit column values in multiple rows together in the same view.

### Video - [Actions for data changes](https://www.cloudskillsboost.google/course_templates/390/video/320409)

- [YouTube: Actions for data changes](https://www.youtube.com/watch?v=jHDPlAIKATg)

Hansel: In this video, we discuss AppSheet actions that you can use to change some of the data used by your app. Data change action types include data: add a new row to another table using values from this row, data: delete this row, data: execute an action on a set of rows, data: set the values of some columns in this row. Let's review each of these actions. With the action type data: add a new row to another table using values from this row, you can quickly add a row of data to another table in your app by specifying the target table and its columns. For example, what if you wanted to automatically create a supplier order when a new product is added via the app? To implement this functionality in our sample app, we create a new action for the product's table. Configure this action by setting the action name, initial supplier order, the table to which it applies, products, the type of action, add a new row to another table using values from this row, the other table to add the new row to, supplier orders, the columns of the supplier orders table and their values that will be used for the new row. After the action is created, you set it as the form saved event action for the products form. This form is used when a new product is added or edited via the app. Now, when a new product is added to the products table via the app, a new supplier order row is also created for that product in the supplier orders table. Note that you can also specify a condition in the action configuration to conditionally execute this action and prompt for the app user's confirmation. The action type data: delete this row can be used to delete the current row in a table. The action type data: execute an action on a set of rows allows you to execute another action on the current table or on a related table. You must provide the related or reference table name, the reference action and an expression that evaluates to a list of row keys from the reference table that this action applies to. This action can be used to make changes to rows that are related to the current row in a table. In our sample app, products are ordered from suppliers when required. If a supplier discontinues specified product, the app user would edit the product to update or remove the supplier information via the app. Any pending supplier orders for that product would also need to be updated or deleted. Let's review how we can implement this using the two actions data: delete this row and data: execute an action on a set of rows. We first create a delete action on the supplier orders table. This table contains a list of orders for a product from suppliers. Here we create a new action and configure it with the action name, delete supplier order, for a record of this table, supplier orders, do this, the action type data: delete this row. Next, we create another action on the products table that will reference a delete action created earlier. For this action we can configure the action name, remove pending supplier orders, for a record of this table products, do this action type data: execute an action on a set of rows, reference table supplier orders, reference rows, a list expression that returns a list of rows from the supplier orders table whose product column value matches the current product ID and whose status is pending. We use the AppSheet filter function for this expression. Reference action, the action to invoke on the reference table supplier orders, which in this case is the action delete supplier order that was created earlier. We only want this action to execute when there is no supplier ID for this product, so in the action configuration we set the expression ISBLANK supplier ID. This expression uses the ISBLANK function which evaluates to true if the supplier ID column of the current row in the products table has no value. We also want the app user to confirm the deletion, so we enable the needs confirmation option and specify the text of the confirmation message that is used to prompt the app user when this action is invoked. Finally, we set the remove pending supplier orders action as the form saved action for the products form and save our changes to the app. Now, when an app user updates a product in the app to remove a supplier, the action executes and the app user is prompted to remove any pending supplier orders. The action type data: set the values of some columns in this row enables you to set or update the value of one or more columns in the current row of a table via the app. You configure the action with a list of the table's columns and the expressions to use to set the column values. Some common uses of this type of action include updating the status of priority of a task or ticket, setting the current date or time, assigning ownership of a job by setting an owner column. Note that you can not use this action type to set the value of a column that contains an app formula or if the type of column is any of the change column types.

### Video - [Actions for external communication](https://www.cloudskillsboost.google/course_templates/390/video/320410)

- [YouTube: Actions for external communication](https://www.youtube.com/watch?v=4iYq3hkC9Ns)

Person: In this video, we discuss AppSheet actions that you can use in your app to communicate with an external service. External communication action types enable you to navigate to a website, open a file, start a phone call, start a text message and start an e-mail from the app. Let's review these action types. Use the action type external: go to a website to navigate to a website URL of your choosing from the app. The target URL value can be an expression that computes the URL at the time the action is triggered. You can also configure the action to open the URL's web page in the app or in the device's own browser. Using our inventory management app as an example, we would like an app user to be able to navigate to the website of a supplier that supplies our products. To implement this functionality in the app, we perform the following tasks. First, create a place to store a supplier's website URL. As supplier table is the most convenient, so we create a new column called website in the suppliers sheet to store the URL. Note that the website URLs used are samples to demonstrate this capability. Next we regenerate the suppliers table structure in the AppSheet editor so that AppSheet can recognize the new website column. Now that the column is part of the suppliers table definition, we can create the action. Navigate to the actions tab in the AppSheet editor to create and configure the supplier website action by specifying the action name supplier website, the table to which this action applies, suppliers, the action type, external: go to a website, the target URL that is obtained from the value of the website column in the suppliers table. You can also set the appearance properties for the action. Action icon, the globe icon is used. Prominence set to display in line with the column value. Attach to column, the icon is displayed in line with the value of the website column in the app. After the new action is saved, the action icon is displayed for each row of the suppliers table in the app. Clicking the action icon navigates the app user to the website URL that is configured for the supplier row in the suppliers table. Use the action type external: open a file to open a file viewer on the device that is running the AppSheet app. You configure the action with an expression that evaluates to the location of the file on your cloud provider's file or storage system. What if you want to provide access to a product's data sheet from within a sample app? Let's create an action to accomplish this using the following steps: create a new action and name it appropriately, load data sheet. Select the table to which this action applies, products. Select the action type, external: open a file. Provide the URL to the file. Because each product will have its own data sheet, the URL is stored in the products table and referenced here as the value of the data sheet column. This column must contain the URL to the data sheet files that are stored on your cloud provider's file or storage system. In the appearance section of the new action configuration, set an appropriate display name for the action, data sheet. Set the action icon, and to display the action icon in the details view of a product set the prominence as display prominently. After the changes are saved to the app, the product details view displays the data sheet action. Clicking on the icon in the live app preview loads the data sheet file in a separate browser tab. Use the action type external: start a phone call to open the phone app on the device running the AppSheet app. You configure the action with an expression that evaluates to the phone number of the recipient. Note that AppSheet automatically generates a call phone action on a table that it recognizes as containing a phone number column. In our sample app, the team members table is one such table. AppSheet applies this action to the table. The action can be invoked by the app user for a specific team member. Clicking on the phone icon in the app will activate the mobile device's phone app to call the number. Use the action type external: start a text message to open the messaging app on the device running the AppSheet app. You configure the action with expressions that evaluate the phone number of the recipient and the text message to send. Like the call phone action, AppSheet automatically generates a send SMS action on a table that it recognizes as containing a phone number column. In our sample app, the team members table is one such table. AppSheet applies this action to the table. The action can be invoked by the app user for a specific team member. Clicking on the message icon in the app will activate the mobile device's messaging app to send the message. Use the action type external: start an e-mail to open the e-mail app on the app user's device. You configure the action with expressions that evaluate to the e-mail address of the recipient, the e-mail subject line and the e-mail body. As with the call phone and send SMS actions, AppSheet automatically generates a compose e-mail action on a table that it recognizes as containing an e-mail address column. In our sample app, the team members table is one such table. AppSheet applies this action to the table. The action can be invoked by the app user for a specific team member. Clicking on envelope icon in the app will activate the mobile device's e-mail app for the app user to compose and send the e-mail.

### Video - [Composite actions](https://www.cloudskillsboost.google/course_templates/390/video/320411)

- [YouTube: Composite actions](https://www.youtube.com/watch?v=hlmK6AHk_Zs)

person: In this brief video, we'll discuss AppSheet composite actions that you can use in your app to group existing actions. To execute a set of actions one-by-one in sequence, AppSheet supports the composite or grouped action type, Grouped-- execute a sequence of actions. For example, you may want to invoke multiple data actions when a form is saved. You may want to add new entries to a related table and remove existing entries, depending on the changes made to the data in the form by the end user. You may also want to send email notifications or log audit entries to inform and capture these data changes. Let's review the steps to use this action using a simple example in a sample app. We want the app user to compose an email message to a team member before deleting that member from the app. To accomplish this, we create a new action and name it appropriately. Select the team member's table and select the action type, Grouped-- execute a sequence of actions. Add the actions in the order that you want them to execute. You can optionally configure the appearance and behavior options, if required. Click Save to save your changes to the app. Now when a user, typically a manager, views a team member's details in the app, they have an action to compose an email and delete the member record. Note that this composite action uses the AppSheet system Compose Email and Delete actions. If you do not want the user to also click the system Delete button to delete the member directly, you can set that action's prominence to not display so that the system Delete icon is not displayed in the app.

### Video - [Lab: Adding Actions to an App in AppSheet](https://www.cloudskillsboost.google/course_templates/390/video/320412)

- [YouTube: Lab: Adding Actions to an App in AppSheet](https://www.youtube.com/watch?v=mufgkuNX8fY)

PERSON: We now invite you to take a lab on the topics discussed so far in this module. In this lab, you'll learn how to create and use app navigation actions in your app, create and use data change actions in your app, create and use actions for external communication, and create and use composite actions to group other actions in your app. To do this lab, click the link provided on the learning platform.

### Lab - [Adding Actions to an App in AppSheet](https://www.cloudskillsboost.google/course_templates/390/labs/320413)

In this lab, you'll use AppSheet to add various types of actions in your app.

- [ ] [Adding Actions to an App in AppSheet](../labs/Adding-Actions-to-an-App-in-AppSheet.md)

### Video - [Automation](https://www.cloudskillsboost.google/course_templates/390/video/320414)

- [YouTube: Automation](https://www.youtube.com/watch?v=_VQ3Nlx0T9g)

Person: We discuss AppSheet automation briefly in this lesson. Note that AppSheet automation is the topic of the third course in this series where we will discuss automation in more detail. AppSheet automation allows you to define automated workflows that are performed on the AppSheet Cloud back end. AppSheet automation involves the following key concepts, the bot, event, process and task. Note that automation has replaced the workflows and reports features in AppSheet. To define the automation that you want to run in AppSheet, you create a bot. A bot has two components; an event, which represents a change to an entity that triggers the bot to run. A process, which is a set of activities or tasks that are performed by the bot when the event is triggered. For example, you can create a bot to send an email, text message or notification, but never a row in a table is modified. You can also define a bot to update or delete rows in a table based on such event conditions. Once enabled, bots run in this background to listen for events. Bots can also trigger processes on a schedule even when a user is not using an app. We discuss how bots are triggered in more detail in the third course of this series on AppSheet automation. An event represents a change to a data entity or table in your app. Events occur when new data is added, or existing data is updated in or deleted from a table via the app, or periodically at a set schedule. A process is a set of activities or tasks that typically represents a business process. An order-approval process is an example of a business process. A simple process comprises a set of tasks that run sequentially and are completed relatively quickly. For example, updating a table and sending an email could be two tasks of a simple process. A more complex process may take longer to complete if it includes time-consuming tasks such as waiting for a human to response, or looping over many rows in a table and performing a task for each row. A process contains the following elements; an input, a row of a table that the process will work on, and a sequence of steps. You add a task as a step in the process. For example, in [indistinct], you can create a process for the supplier's table and send an email whenever a new supplier is added to the table via the app. A task is a simple activity that runs relatively quickly. For example, you can send someone an email or text message, change data, or call on external servers from an app. You add a task as a step in the process. Tasks can be reused across processes. AppSheet supports the following types of tasks; send an email, send a notification, send an SMS message, call a webhook and create a new file. We will revisit tasks and processes when we discussing using webhooks in a later module in this course.

### Video - [Using offline sync](https://www.cloudskillsboost.google/course_templates/390/video/320415)

- [YouTube: Using offline sync](https://www.youtube.com/watch?v=CkyUPWQ4V3U)

Hansel: In this lesson, we discuss how you can configure your app to operate when it is offline or has limited Internet connectivity. AppSheet apps can be used on a mobile device even when that device is offline and disconnected from the network. This is possible because the information needed to run the app, the app definition, the data and optional images and documents is stored locally on the mobile device. For offline access to work, however, the app must initially be launched on the device when it is online. This allows the required information to be downloaded and stored locally. As the app creator, you control the offline or delayed sync behavior of your app in the offline and sync tab in the AppSheet Editor. Sync is the process that your app uses to send data updates from the app user's device to the AppSheet back end and to retrieve the latest app definition and data from the back end to the device. This topic discusses the delayed sync capability in AppSheet. To allow the app user to control when the app sends data between the device and the back end, you can enable the delayed sync feature. With this feature enabled, any data or app definition changes are queued up and then synced only when the user clicks the sync button in the app. You should select this option for apps that are expected to work in offline environments or where you want the user to control their use of network bandwidth. Apps that don't enable delayed sync will attempt to synchronize changes every time the data changes on the device. Even in a connected environment, there may be intermittent connectivity problems that prevent synchronization from succeeding. In this case, AppSheet automatically queues changes and defaults to the delayed sync behavior to prevent the loss of the data. Table data is automatically copied to the device so that it is available when the device is offline. However, images and documents are not copied to the device by default because they may be large and could consume a lot of device storage. You can enable offline content caching to tell AppSheet to copy images and documents to the device. When this is enabled, images and documents are copied to the device when the app is initially run on the mobile device while online. They are refreshed as needed when sync occurs. Note that depending on the number and size of your images and documents, it may take several minutes for all of your content to be downloaded and saved on the device. Also, note that video and audio files cannot currently be stored offline on the app user's device. By default, a mobile device must be online in order to launch an app from the home screen. After it is launched, the app can then function offline or with intermittent connectivity. To enable a user to launch an app while their device is offline, you can set the option to start the app when offline in the offline sync tab of the AppSheet Editor.

### Video - [View events](https://www.cloudskillsboost.google/course_templates/390/video/320416)

- [YouTube: View events](https://www.youtube.com/watch?v=naLI_wawtX4)

Person: Let's now discuss some additional AppSheet capabilities that you can use to configure your app. View events enable you to configure actions that run when certain events occur in the app such as selecting a row in a table, view or saving a form. These actions can replace the default app navigation behavior, enabling you to create custom navigation within your app. View events are connected to actions within the view configuration of supported view types in the UX views tab of the editor. The list of actions shown in the view configuration depends on the type of view. You can use actions for the following types of view events. Row selected: The row selected event is triggered when an app user taps on an individual row in a table, deck or gallery view. An action configured for this event replaces the default app behavior of displaying the row details in a detail view. With the default behavior, selecting or clicking a row of data in the app navigates the user to the details view of that row. By configuring this view event to use the edit action, you can navigate the user directly to the edit form view when a row of data is selected in the app. Now, when selecting or clicking a data row in the app, the user is taken directly to the edit form view where they can edit and save any changes to the data. The form saved event is triggered when a user saves a form while adding a new row or editing an existing row of a table in the app. An action for this event replaces the default navigation behavior. Note that unlike the row selected event action, if a form saved action is configured that doesn't cause navigation, the default navigation behavior will still occur. To configure a view event, you can create your own action in the actions tab of the editor as described earlier in this module. Eligible actions can then be selected as event actions in the view configuration. Note that only actions that are based on the same source table as the view are eligible to be selected as event actions. Actions that are based on tables different from the view will not appear in the view event configuration. If you don't see the action you want as an option, make sure the tables match. System-generated actions can also be chosen for a view event. The default auto option corresponds to the built in behaviors normally associated with each event. To configure form saved events, you may need to create a new form view first if one does not already exist. Multiple behaviors for one event can be combined by providing a composite action. Not all view types currently support event actions. Currently you can configure actions for the row selected event and table, deck and gallery views, and for the form saved event in form views. Let's see this in action by implementing a confirmation action whenever a new team member is added via our sample app. The sample app contains a team member's view that lists all the members that work with the app. After a new member is added via the app, instead of navigating the app user back to the member list view, we would like to ask the user for confirmation to send an e-mail to the new member via the app. To add a new team member, an app user clicks add, fills out the form in the app and clicks save. The default behavior of the form saved action is to navigate the user back to the team members list view after the new row is saved to the table. Let's create a new action to replace the default form saved navigation behavior. Navigate to the actions tab in the AppSheet editor, and configure a new action by clicking new action and entering the following information: action name, send team member e-mail. For a record of this table, select the team members table. For the type of action, select grouped. Execute a sequence of actions. Note you can also select the external start and e-mail action type here. Next, enable the needs confirmation option to prompt the user for confirmation. Provide the confirmation message that will be displayed in the confirm dialogue in the app. We can now edit the team members' form view and set this event action. Expand the form view definition, and set the form saved event action to the send team member e-mail action that was created in the previous step. Finally, we save all our changes to the app. Now when the app user adds a team member and clicks save, they see a confirmation dialogue open in the app. Clicking on send team member e-mail in the dialogue opens a separate browser tab where the app user can compose and send an e-mail to the team member.

### Video - [Customizing input forms](https://www.cloudskillsboost.google/course_templates/390/video/320417)

- [YouTube: Customizing input forms](https://www.youtube.com/watch?v=ZgcBoHRclMw)

Person: In this lesson, we discuss how you can customize forms that accept user input to your app. You enable app users to add and edit data in a table using forms in the app. Every form is connected to a table where the data is stored. A form or form view consists of a sequence of labels or table column names, input fields that correspond to the table's columns and are specific to the column data type. You can customize a form using column display names and descriptions. To use a name that is different from the column name or provide a verbose prompt for an input field, you can set the display name and optionally the description properties of that column. In the example, the display name property of the price column in our products table is set to product price. As seen here, we also set the description property of the price column. If both the display name and description properties are set, the value of the description property is used in the form. Form layout options, you can configure the layout of the form and other form characteristics in the UX options tab in the AppSheet Editor. Form page style controls how multipage forms are displayed in the app. We discuss this topic in the next section. Form style determines the layout, top down or side by side, of the column names and fields in the form view. To prevent displaying a number for each form field in the view, you can enable the hide form numbering option. To enable advancing the app user to the next field or next page in a multipage form, use the advance forms automatically option. Show-type columns are empty columns in your spreadsheet that serve the sole purpose of improving the presentation of forms in your app. There are six categories of show types: page header, section header, text, URL, image and video. Page header, a page header show column type is used to create a new page within a form. Let's customize a product form to display related fields on separate pages in the app. To do this, we perform the following steps. Add a page break column to the underlying product sheet where we want the page break to appear. In the example, we are grouping the product inventory and shipping and receiving data on separate form pages in the app. Regenerate the table column structure in the AppSheet Editor. Edit the page one column definition and set the type property to show, the category property to page header, the content property to product details. The content property provides the name of the form page where it is displayed in the app. Configure the page two and page three columns similarly. Using page headers, the product form now contains multiple pages where the app user enters information while adding or editing a product via the app. To step through the pages in the form, the app user clicks next or previous. In the UX options tab of the editor, you can further configure the form page style of the multipage form to display the form pages using page count format. This format displays a set of breadcrumb circles indicating the position of the page that the user is currently on. Tabs format, this format displays the form pages on separate tabs in the app. Section header, this type of show column allows you to create a new section within the same form page. For example, to display the shipping and receiving form fields on the inventory details form page, we can set the category of the page three show column to section header. Text, to display descriptive text on a form page, you can set the show columns type category to text and set the content to the text value. URL, to display a clickable URL on a form page, you can set the show columns type category to URL and set the content to the URL value. Image, to display an image on a form page, you can set the show columns type category to image and set the content to a publicly accessible URL to the image. Video, to include a video on a form page, you can set the show columns type category to video and set the content to a publicly accessible URL to an MP4 video or to the embed link of the YouTube video. What if you want to display or skip a page of a form in the app based on a certain condition? AppSheet makes this easy to implement using a Show-If conditional expression. In our products form example, say we want to skip displaying the inventory details form page if the app user edits or adds a product that is in the utility product category. To implement this, edit the column definition of the page two column in the AppSheet Editor. Using the Expression Assistant, provide a Show-If conditional expression that evaluates to yes or no. The conditional expression checks the value in the product category column of the product selected by the app user. The inventory details page in the form will only be displayed in the app for products that are not in the utility product category. When a product is added or edited in the app with the utility product category selected, the Show-If expression evaluates to no or false, and the inventory details form page is disabled or grayed out in the app. To learn more about conditional branching of forms, view the documentation on the AppSheet website.

### Video - [Lab: Using View Events and Custom Forms in AppSheet](https://www.cloudskillsboost.google/course_templates/390/video/320418)

- [YouTube: Lab: Using View Events and Custom Forms in AppSheet](https://www.youtube.com/watch?v=AOgUH8WKxcQ)

PERSON: We now invite you to take a lab on the topics discussed in this module. In this lab, you'll learn how to connect actions to view events in your app, customize the layout of input forms in your app, and implement conditional branching for forms in your app. To do this lab, click the link provided on the learning platform.

### Lab - [Using View Events and Custom Forms in AppSheet](https://www.cloudskillsboost.google/course_templates/390/labs/320419)

In this lab, you'll use AppSheet to create and use view events and custom forms in your app.

- [ ] [Using View Events and Custom Forms in AppSheet](../labs/Using-View-Events-and-Custom-Forms-in-AppSheet.md)

### Quiz - [Quiz](https://www.cloudskillsboost.google/course_templates/390/quizzes/320420)

#### Quiz 1.

> [!important]
> **What is a show-type column used for in AppSheet?**
>
> - [ ] To highlight the value of a column in the app
> - [ ] To show or hide a column's value in the app
> - [ ] To store read-only data for display in the app
> - [ ] To improve the presentation of forms in the app

#### Quiz 2.

> [!important]
> **Which statements regarding AppSheet view events are true? Select 2.**
>
> - [ ] View events enable you to create custom navigation within your app.
> - [ ] View Events enable you to configure actions that run when certain events occur in the app, such as saving a form.
> - [ ] All types of views in AppSheet support view events.
> - [ ] You must configure a view event action for every view in your app.

#### Quiz 3.

> [!important]
> **Which of the statements regarding offline app access are correct? Select three.**
>
> - [ ] Images and documents must always be stored with your cloud provider and cannot be cached on the app user's device.
> - [ ] As the app creator, you can enable the app user to control when the app syncs data between the device and the backend.
> - [ ] AppSheet apps can be used on a mobile device even when that device is offline and disconnected from the network.
> - [ ] For offline access to work, the app must initially be launched on the device when it is online.

#### Quiz 4.

> [!important]
> **In AppSheet, an action is an operation that changes the state or navigational behavior of the app. What capabilities can you achieve with actions in your app? Select three.**
>
> - [ ] Delete a table from your app.
> - [ ] Delete a row from a table.
> - [ ] Execute a sync operation from an app.
> - [ ] Navigate the user from one app to another.
> - [ ] Open a form to add or edit a table row.

#### Quiz 5.

> [!important]
> **Which of the following components are used to implement automation in AppSheet? Select four.**
>
> - [ ] Event
> - [ ] Process
> - [ ] Rule
> - [ ] Task
> - [ ] Bot

### Video - [Module Review](https://www.cloudskillsboost.google/course_templates/390/video/320421)

- [YouTube: Module Review](https://www.youtube.com/watch?v=VO0hvuk8HiA)

PERSON: Congratulations on completing this module on adding behaviors to your app. Let's do a quick review. In this module, you learned about the various types of actions that are available in AppSheet and how we can use them to add behaviors to your app. We also briefly discussed AppSheet's automation capabilities and how you can configure your app to operate when it is offline or has limited internet connectivity. You also learned about additional AppSheet UI capabilities, like view events, that enable you to execute actions on certain events, like saving a form and how to customize input forms to collect data from users via the app.

## Securing Your App

Learn how to secure your app with AppSheet's security features.

### Video - [AppSheet security](https://www.cloudskillsboost.google/course_templates/390/video/320422)

- [YouTube: AppSheet security](https://www.youtube.com/watch?v=XGjXKPdh-BU)

Hansel: Securing your app is one of the key considerations you must take into account when developing your app. In this module, we discuss how you can leverage AppSheet's security architecture to implement security for your app. We first discuss the security capabilities of AppSheet and how you can use these capabilities to secure your app. You will learn how to implement access control for your app and for the data used by the app. You'll learn how to authenticate and authorize users of your app and how to use AppSheet's auditing features. Let's start with AppSheet's security. In this lesson, we discuss the security features in AppSheet and how you can use them to make the apps that you create secure. The security of your app is based on AppSheet's security architecture, the underlying security architecture or your cloud data provider and security options that you control. Let's review each of these in turn. AppSheet's security architecture comprises the following: application and data access control. Access control enables you to control who can run your application. Data access control enables you to control the set of data that is accessible to app users. Authentication and authorization enables you to reliably identify users of your application and validate that they are who they say they are. It also determines the functions they can perform in the app and the data they can manage based on their role and permissions. Auditing enables you to monitor the use of your app. We'll review each of these capabilities in subsequent videos in this module. Your cloud data provider security architecture manages access to your data files that are used by your AppSheet apps. Data that is used by your app is stored in your cloud data provider's system. For example, this could be on Google Drive, Google Cloud platform, Dropbox, Box, Smartsheet, Office 365, et cetera. AppSheet does store your app's data. You manage the permissions of your data files using our cloud data provider's access control mechanisms. You can grant or deny access to your data files to other AppSheet users by setting the correct sharing permissions on those files. It is preferred and recommended for users of your app to not have direct access to the app's data files that are stored with your cloud data provider. The cloud provider permissions or sharing settings on the data files determines who has access to the files and at what level of access: view only or read/write. In some scenarios, apps are built from data sources like spreadsheets that are also shared with other users outside of AppSheet. In this case, the sheet should be an exclusive data source just for the app. You use the permissions that you set for each table used in your app to control end user access to the app's data. Based on these settings, an app user may be able to add, edit or delete data in the app's tables via the app. Data synchronization, where an app user adds, updates or deletes data via your AppSheet app running on their mobile device, all changes are saved to your cloud data provider. For example, submitting a form in an app will add a row to a connected Google Sheet. The AppSheet cloud service acts as an intermediary to connect the mobile app with the cloud data provider used by your app. Communication between the mobile device and the AppSheet cloud service uses the HTTPS with secure web protocol. Communication between the AppSheet cloud service and your cloud storage provider also uses the secure HTTPS web protocol. That apps that you create are saved as application definitions that are maintained by AppSheet in a separate secure cloud database. The AppSheet cloud service requires permissions to act on behalf of the app creator or app user to read and write your app's data to and from your cloud data provider using OAuth tokens. These permissions are only used for the specific purposes of app creation and app execution. Also because of the way the OAuth protocol works, you can decide at any time to disable the access permissions granted to AppSheet. The application definition and all the necessary data are copied to the mobile device and securely stored locally on the device using HTML file local storage. As the app creator, you control end user access to the app's data using the permissions that you set for each table or slice used in your app. Let's review how you can set a table's permissions in AppSheet. Navigate to the data tables tab or the data slices tab in the AppSheet editor. Expand the table or slice configuration. For example, the product categories table shown here. Select the update mode that allows your app user to update, add or delete rows in the table. If none of these modes is allowed, select the read only mode. Save your changes. Let's review the options that you can set to control user access to your app. Controlling who has access to your app is a three step process. First, you must enable the require user sign-in option. Enabling this option will require app users to sign into your app before being able to use it. Choose an authentication provider. AppSheet supports many authentication providers including Google, Microsoft and Apple. Specify which users or email domains can use your application. We will discuss these steps in more detail in the authentication and authorization topic later in this module. As the app creator, you can also control access to specific data where the app by user classes. For example, you may want certain classes or groups of users to only have access to view specific subsets of data and other users to access different sets of data. You can implement this in AppSheet using slices or using security filters. We discussed slices in an earlier module in this course, and we discuss how to implement this use case later in this module.

### Video - [Application access control](https://www.cloudskillsboost.google/course_templates/390/video/320423)

- [YouTube: Application access control](https://www.youtube.com/watch?v=doH2jNuSv00)

Person: Let's now discuss application and data access control for your AppSheet app. In this video we discuss how you as the app creator can control access to your app with AppSheet's access control features. Application access control involves controlling application discovery, requiring user authentication, granting application access. Let's review these procedures in more detail. How do potential users discover or find out about your app? AppSheet does not have it's own app store where users can browse for apps to download and use. AppSheet does have an app gallery that is available to end users and which can be used to launch apps on iOS and Android devices. Also, many organizations use AppSheet to build their own app portals that contain links to the apps available to their teams. As the app creator, you inform others about your app by sharing an installation or browser link with them. These users can then, in turn, share the app with other users. This is how your app gets discovered, which then prompts a question: How do you control access to the app now that it is shared by many users? To control access to your app, you must require users to sign in to your app using an authentication provider. You can choose to grant access to individual users. You grant access to individual users by creating an allow list of user email addresses. Only the users in this list will be able to sign in and use the app. Or an entire user email domain, when many users belong to an organization and share the same email domain name, you can grant access to all such users by creating a list of allowed domain names, all signed-in users. If you do not need to restrict access to individual users or domains, you can grant access to all signed-in users. With this option enabled, you do not need to maintain an allow list of individual user email addresses or domains. You can still access the signed-in users' email address and use features like security filters and private tables, which are discussed later in this module. Members of a domain group, in many organizations, it is common to use security groups at the domain level. Using this advanced feature available in AppSheet corporate plans, you can configure your apps to provide access only to members of a specific domain group. The advantage of using domain groups is that access-controlled decisions can be made centrally rather than in each app. For example, if there is a domain security group called admins, you can set up your app to only be accessible to members of this group. As specific employees are added or removed from the group, their access to the app also dynamically changes. To configure domain groups for an app in AppSheet, follow these steps. Navigate to the My Account Integrations tab in the AppSheet UI. Select Org Domains from the left menu. Click New Org Domain to add a new domain authentication source. Select the authentication domain from the list of supported authentication sources, for example, Google Domain. Log in to the OAuth service provider using the app creator account. This account must have permissions to read the list of domain groups and the membership of each group. After the org domains are added, they are displayed in the AppSheet UI. Navigate to the security domain authentication tab in the AppSheet editor. Enable the Require Domain Authentication option. Selection the authentication domain source that was added in the previous steps from the list. Provide a user-friendly name called the authentication domain source, and save your changes to the app. Your app is now accessible to anyone in the domain security group. To configure a domain group for access control using Google Domains, see the documentation on the AppSheet website.

### Video - [Data access control](https://www.cloudskillsboost.google/course_templates/390/video/320424)

- [YouTube: Data access control](https://www.youtube.com/watch?v=z0w9J6KDaDA)

Person: The data access control, you can ensure that your app users access data securely and that only authorized users can retrieve and update data in a manner that meets privacy and compliance requirements. Where requiring users to sign into your app using their individual cloud provider credentials, you can filter and isolate an app user's data from other users. You can implement data access control in AppSheet using security filters for your app. Security filters are discussed in detail in a later lesson in this module. Role-based access control is a form of data access control that uses role permissions and privileges to enable access to authorized users. In an RBAC implementation, every app user is assigned a role that determines the permissions granted to the user. For example, a user may have administrative privileges based on the permissions assigned to them with an admin role. Other users may be assigned a manager role, a member role, et cetera. Actual roles will depend on the needs of your organization. Implementing RBAC in AppSheet is straightforward with security filters and settings for each table used in your app. The actual implement of RBAC will vary among organizations and depend on their security and access control policies. To set up simple RBAC capability for an app using AppSheet, you can follow these steps: Create a table to store user role assignments. This table will contain columns to store a unique ID, the user's e-mail address or ID and the role name. Create a security filter for each table in the app that references the user e-mail function in AppSheet to retrieve the e-mail address of the app user, and then look up their role in the user roles table to apply the filter. We discuss and implement security filters using a sample app in the next lesson. AppSheet also supports default admin and user roles for your app that can be defined in the user allow list in the AppSheet UI. By assigning the admin or user roles to an app user and requiring users sign in for your app you can use the user role function to determine the role of the signed-in user in table updates, security filter and column constrained expressions.

### Video - [Authentication and authorization](https://www.cloudskillsboost.google/course_templates/390/video/320425)

- [YouTube: Authentication and authorization](https://www.youtube.com/watch?v=1lC3AkhlsMI)

Hansel: Let's now discuss some key aspects of AppSheet's security architecture that you use to implement security for your app. In this video, we discuss how you can implement authentication and authorization for your AppSheet app. Authentication refers to the process of determining who is using your app and whether the person is actually who they claim to be. Authorization refers to the set of activities the user is allowed to perform based on the permissions granted to them after they are authenticated. Authentication and authorization apply to app creators. As an app creator, you sign into AppSheet with your cloud provider account and give AppSheet the permission or authorization to read and write data that is stored on the cloud provider on your behalf. The industry standard OAuth protocol is used in this process. App users, to restrict access to your app, you must require app users to authenticate with the cloud provider by signing into your app. After the user is signed in, additional restrictions built into the app may authorize the user to perform only certain actions within the app based on their account credentials. You should require user sign-in if your app provides access to confidential data like personal, employee or company data. You want to customize your app's behavior based on the signed-in user. Your app can only be used by a select group of users. An audit trail of users who access your app is required. Your app uses private tables. We discuss private tables later in this module. Apps that require users to sign in support the following security features. Authentication provider, you can use a specific authentication provider for user sign-in like Google or Dropbox where the app user already has an account. User allowlist, specify a user allowlist that contains only those users who are explicitly allowed to access the app. Security filters, use security filters to manage access to subsets of data by different users. Auditing, implement auditing of app user activity. As part of the configuration needed for user sign-in, you configure an authentication provider that is used to validate the user's credentials when they sign into your app. To require user sign-in for your app, follow these steps. Navigate to the security require sign-in tab in the AppSheet Editor. Enable the require user sign-in option. Select a specific authentication provider or the any provider option from the list. App users must have an account with the authentication provided select or if the any provider option is selected, with any of the providers. Optionally, enable the allow all signed in users option. If you enable this option, you do not need to create an explicit user allowlist. If you do not enable this option, you must create an allowlist of users to grant them access to the app or share access with an entire domain. To create a list of allowed users for your app, click the share icon in the title bar at the top of the AppSheet UI. You can also click manage users in the require sign-in tab. Clicking the share icon opens the share app dialog in the AppSheet editor. Here you can add users with the appropriate role and permissions to provide them access to your app. Type the email address of the user in the dialog and press enter. Set the app permissions for the user and pass the RECAPTCHA challenge. You can make the user a co-author of your app by setting the permissions to edit definition. This setting is usually used when sharing your app with other app creators in our organization. You can choose to customize and send an email invitation to the user. Instead of adding each app user's email separately as described earlier, you can enable an entire email domain by adding the required domain names in the dialog and following the steps listed earlier. This is typically done when you share the app with all users in an organization or company. For example, you may have users with emails like bob@company.com and alice@company.com that work at a firm named Company. In this case, the domain company.com can be added to the list of domain names to allow any user with an email address that uses that domain to sign into the app. When you need to revoke a user's access to your app, follow these steps. Click the share icon in the title bar at the top of the AppSheet UI. You can also manage users in the require send tab. In the share app dialog, select the permission lists of the user whose access needs to be revoked. Click remove. The process to revoke access for an entire email domain is similar to that for individual users. We discuss security filters and AppSheet's auditing capabilities in the next lessons in this module.

### Video - [Security filters](https://www.cloudskillsboost.google/course_templates/390/video/320426)

- [YouTube: Security filters](https://www.youtube.com/watch?v=qkxJo_oe7P8)

Person: Let's discuss what security filters are and how we can use them in AppSheet to filter data for the app's users. Security filters are optional Yes/No expressions that are associated with each table in the app. They typically use the user's email address and possibly other data values to limit the data shown to the app user. They are used as a form of authorization to control the set of data or app functionality available to the signed-in user. To use security filters, you require app users to sign into your app using the steps outlined in the previous video. Use expressions with AppSheet built-in functions to filter the data shown to the user. Use a column in a table that identifies the owner of rows in the table. Typically the value in this column would be the app user's email address. Use AppSheet's USEREMAIL function in the column's initial value property so any new rows that are added to the table get automatically populated with the signed-in app user's email. USEREMAIL returns the email address of the current signed-in app user. Use the column value with the USEREMAIL function in a Yes/No expression where needed to limit access to data, views or actions in the app. Let's see this in action in our sample app. One of the tables used in the app is Team Members, which contains information on each team member using the app. We would like to restrict updates to a given team member's information to be made only by the user of the app who is the signed-in team member so that an app user can only update their own information and no one else's. To implement this capability, follow these steps. In the actions tab in the AppSheet editor, expand the system edit action for the Team Members table. You may need to click show system actions at the bottom if these are not already displayed. Expand the behavior section of the edit action. In the condition field, click the icon to open the Expression Assistant. In the Expression Assistant, select the columns tab. Find the email column and click insert to insert this column in the expression field. Edit the expression field to add equals USEREMAIL and click save. This expression will return true or false if the value in the email column for the current row matches the email of the signed-in app user or team member. Click save to save the expression and set it as the condition for this action. The action will now only display the edit icon when the behavior condition is true. Save your changes in the app. Now, as a signed-in app user, when you click on a team member in the app, the edit action icon in the detail view is only available for your own row and not for other team member rows. Note that the signed-in app user's email is displayed in the app preview at the bottom. What if you don't want any app user other than a team member manager to be able to add new team members via the app? To implement this functionality in our sample app, we follow these steps. A mechanism is needed to assign roles to different team members that use the app. We discussed RBAC earlier in a previous video, which we will now implement for this use case. To identify a team member as a manager, you add a row in the user roles table with the manager's email address and set the role as manager. Note that for this sample app the user roles table also stores the email address of the user, but it can also be fetched from the Team Members table using a ref column. Navigate to the actions tab in the AppSheet editor and expand the add system action of the Team Members table. From there, expand the behavior section. In the condition field, click the icon to open the Expression Assistant. Edit the expression field and type the expression shown. This expression uses the AppSheet SELECT function along with the IN function to return true or false if one of the roles of the signed-in app user is manager. The list of roles is retrieved from the user roles table using the signed-in app user's email address. Click save to save the expression and set it as the condition for this action. The app will now only display the add icon when the behavior condition is true. Save your changes in the app. Now when an app user who is not the team member manager signs into your app, the add system action icon is not displayed in the team member's view. How would you now also allow a manager to edit any team member row when the manager is signed in as the app user? Let me share a hint. AppSheet supports the OR function. You can pause the video here as you think about the solution. AppSheet has an OR operator that you can use with conditional expressions that returns true if any of the conditions is true or false if all of the conditions are false. Each condition is separated by a comma. The solution to the question is to combine the previously used expressions using the OR operator. The first condition checks whether the signed-in app user's email address matches the email of the current row in the table owner of the team member record and the second condition checks whether the signed-in app user is a manager based on the roles assigned to the user in the user roles table. In addition to filtering data using conditions and actions, you can also limit user access to specific tables and views. You can control which views are shown to the user by using the show_if constraint expression as part of the view definition. To further control access to data, you can use an expression to compute the update mode of a table. Instead of statically defining the update mode, update, add, delete, read_only, in the table definition you provide an expression. Let's implement this for our Team Members table in our sample inventory manager tab using these steps. Navigate to the data tables tab in the AppSheet editor and expand the Team Members table definition. For the updates allowed condition, click the icon to open the Expression Assistant. In the expression field, type the expression shown. This expression uses the AppSheet's SWITCH statement with the LOOKUP function expression to return the all changes value if the current signed-in app user is a manager, to return the updates_only value if the current signed-in user is a member and to return read_only for all other signed-in app users. Click save in the Expression Assistant and save the changes to the app. Note that this has the same intended effect as the previous scenario where we hid the system add action icon for signed-in app users that are not managers. The difference is that this implementation applies to the table as a whole, so it would apply to any action defined for the table. Note the delete icon is also not available for the team members detail row. The previous implementation enables you to control access at a more granular action level. The allowed values that can be used to dynamically set the update mode of a table are READ_ONLY, UPDATES_ONLY, ADDS_ONLY, ADDS_AND_UPDATES, DELETES_ONLY, UPDATES_AND_DELETES, ADDS_AND_DELETES and ALL_CHANGES. Finally, in order to restrict your app to use only a subset of rows from a given table, you can specify a filter condition on the table. You can use this filter to limit what each user can see in the app. You can also set this filter condition by navigating to the data tables tab in the AppSheet editor and expanding the security section of the table configuration. Let's now discuss the AppSheet access mode that is used by AppSheet to communicate with your cloud data provider. Apps that you build with AppSheet communicate with the AppSheet back-end cloud service. The AppSheet back-end, in turn, communicates with your cloud data provider, for example, Google Drive, to read or update your data. For security reasons, cloud data providers only let AppSheet access your data after you grant AppSheet permission to do so. Whenever a user or app creator signs into the app, they grant AppSheet permission to act on their behalf when interacting with the cloud data provider. Access mode refers to the identity that AppSheet uses when it communicates with the cloud provider to access the sheets and tables used by your app. AppSheet lets you configure one of two access modes for each table used by the app, App Creator and App User. App Creator: By default, AppSheet uses the App Creator access mode to access data stored on the cloud provider. This means it uses the identity of the app creator who has access to the data sheets stored on the cloud provider. The App Creator access mode enables an app creator to distribute apps to other users who do not have direct access to the data sheets stored on the cloud provider and restrict direct access to the data sheet solely to the app creator. App User: As the app creator, you can set the access mode to App User. In this mode, AppSheet accesses the data sheet stored on the cloud provider using the identity of the app user. The app must require user sign-in. All app users must have the necessary permissions to access the data sheets on the cloud provider. The App user access mode enables you, the app creator, to rely on the permissions model of the cloud data provider, possibly enforcing stricter security principles and leverage the auditing capabilities of the cloud provider to review data changes made by app users. To change the access mode for a table, navigate to the security, security filters tab in the AppSheet editor. Expand the table configuration of the table whose access mode needs to be changed. Select the as App Creator or as App User access mode. Save your changes to the app. The access mode can also be changed in the data tables tab in the AppSheet editor in the security section of the table configuration.

### Video - [Auditing](https://www.cloudskillsboost.google/course_templates/390/video/320427)

- [YouTube: Auditing](https://www.youtube.com/watch?v=0xjIi7J-Fm8)

Person: For some apps and organizations, it is important to track who makes updates to your app's data. AppSheet generates an audit history log that contains a record of recent activity that occurs in your app. It captures the identity of any user who interacts with your app. The audit history log contains an entry for every sync between your app and the AppSheet backend, Add, Edit, or Delete activity made by users of your app, Add, Edit, Delete, Action, and Read calls made via the AppSheet API, invocation of a bot. To review the audit history, navigate to the manage, monitor tab in the AppSheet UI. Expand the "audit history" section. Click "launch log analyzer" to open the audit history log in a separate browser tab. The audit history shows summary charts of recent log entries by user and by operation. It also displays a table of the recent operations made by the users of the app. You can filter the audit history logs using time range, operation, failures, table, user ID. As the app creator, you can subscribe to automatically receive an email alert each time an error is recorded in audit history. Audit history alerts are available as part of the AppSheet enterprise plan. To enable or disable audit history alerts, navigate to the manage, monitor tab in the AppSheet UI, expand the audit history section, enable or disable the audit history alerts option and click "change settings." You can also use the cloud data provider's auditing mechanism to determine the changes to the audit data files used by the app. Google Sheets provides an edit history for changes made to this sheet that displays who made the change and when. In order to use this backend audit history, you must set the AppSheet app's access mode to "app user." Each user should also be given sufficient permissions to access the backend data files on the cloud data provider.

### Video - [Lab: Securing Your AppSheet App](https://www.cloudskillsboost.google/course_templates/390/video/320428)

- [YouTube: Lab: Securing Your AppSheet App](https://www.youtube.com/watch?v=ku142X78E-o)

PERSON: We now invite you to take a lab on the topics discussed in this module. In this lab, you'll learn how to authenticate your app's users with AppSheet's security features; limit a user's access to data in your app; implement Role-Based Access Control, or RBAC, in your app; understand how to use the AppSheet audit history log; and configure your app to handle sensitive data. To do this lab, click the link provided on the learning platform.

### Lab - [Securing Your AppSheet App](https://www.cloudskillsboost.google/course_templates/390/labs/320429)

In this lab, you'll use AppSheet's security features to secure your app.

- [ ] [Securing Your AppSheet App](../labs/Securing-Your-AppSheet-App.md)

### Video - [Private tables](https://www.cloudskillsboost.google/course_templates/390/video/320430)

- [YouTube: Private tables](https://www.youtube.com/watch?v=_frLXFfchMg)

Person: Let's discuss some additional security measures for managing data privacy in AppSheet. By default, all tables in an app are owned by the app creator and shared across all users of the app. In some use cases your app might require individual per user data. Some examples of such apps are a test practice app that uses a common or shared set of questions but each student's answers must be private to that student, an exercise app that contains shared workout routines but each user records their own progress in the app, an app with a note-taking feature that enables each user to take notes and use them privately within the app. A private table is defined just like any other table in AppSheet with a columns structure and a spreadsheet or the data source. To configure a private table, follow these steps. Navigate to the data tables tab in the AppSheet editor, expand the table definition, expand the security section in the table definition, disable the shared option to mark the table as private. Note that the shared option is enabled by default. How do private tables work in AppSheet? Each app user gets a private copy of each private table's data that is used in the app. The copy is stored in the user's Cloud provider account and initialized with the data provided by the app creator in the original table definition. The data in the private table is accessible only to the specific user for whom it was created. Each user's changes are made independently. If the same user accesses the app from different devices using the same account to sign in, the same private table is used from each device. This is a benefit of storing the private table in the Cloud provider system instead of locally on each device. The following restrictions apply when an app uses private tables. An app with private tables must require a user sign-in. When using private table data, make sure the associated worksheet is the only worksheet in the workbook. The app can still use other workbooks with multiple worksheets for other tables. Because each app user gets a copy of the original worksheet, any subsequent changes to the table's column structure will only be available to new users of the app. This may cause the app to break for existing users, so it is recommended to finalize the private tables column structure by sharing the app with end users.

### Video - [Using sensitive information](https://www.cloudskillsboost.google/course_templates/390/video/320431)

- [YouTube: Using sensitive information](https://www.youtube.com/watch?v=SpnZGWI9ENc)

Person: Some apps process sensitive or personal information, generally known as PII, or personal identifiable information. Such apps can be configured at the app or individual column level to treat the values stored in the table columns as sensitive and not recall this data in the AppSheet system logs or in the app audit history log. To configure this setting for each table column, edit the column definition and expand the "other properties" section. Check the "sensitive data" option and save your changes to the app. To configure this option at the app level and override any column-level setting, navigate to the "security options" tab in the AppSheet UI. Enable the "treat all data columns as sensitive" option and save your changes to the app.

### Quiz - [Quiz](https://www.cloudskillsboost.google/course_templates/390/quizzes/320432)

#### Quiz 1.

> [!important]
> **To control individual user access to an AppSheet app, what should an app creator do? Select three options.**
>
> - [ ] Enable the Require user signin option.
> - [ ] Enable the option to Allow all signed-in users.
> - [ ] Use a security filter.
> - [ ] Select an authentication provider.
> - [ ] Create a list of allowed users or email domains.

#### Quiz 2.

> [!important]
> **What does the update mode of a table or slice in AppSheet allow an app creator to do?**
>
> - [ ] Control whether an app user can update, add, or delete data rows in a table or slice.
> - [ ] Control whether an app user can only update or delete data rows in a table or slice.
> - [ ] Control whether an app user can only update data rows in a table or slice.
> - [ ] Control who has access to your app.

#### Quiz 3.

> [!important]
> **Access mode refers to the identity that AppSheet uses when it communicates with the cloud provider to access the sheets and tables used by your app. What are the two access modes used by AppSheet?**
>
> - [ ] App User
> - [ ] App Creator
> - [ ] App Viewer
> - [ ] App Admin

#### Quiz 4.

> [!important]
> **Which statements correctly describe security filters in AppSheet? Select three.**
>
> - [ ] Security filters can be used to validate user input to your app.
> - [ ] Security filters are used to control access to data or functionality for a user who is signed in to an app.
> - [ ] Security filters are Yes/No expressions that are associated with each table in the app and commonly use the user's email address to limit the data shown to the app user.
> - [ ] Security filters help to improve the performance of your app.

### Video - [Module Review](https://www.cloudskillsboost.google/course_templates/390/video/320433)

- [YouTube: Module Review](https://www.youtube.com/watch?v=yzWWBJJOQlI)

PERSON: Congratulations on completing this module on securing your AppSheet app. Let's do a quick review. In this module, we discussed the security architecture of AppSheet, and you learned about the security options that are available to secure your app. You learned how you, as the app creator, can control access to your app and its data. You learned how to implement authentication and authorization for your app and how to use security filters. We also reviewed the auditing capabilities provided by AppSheet for activities performed by your app and its users. Finally, we discussed additional security topics on using private tables and how to handle sensitive information in your app.

## Integrations

Integrate your app with external applications and services providing access to the data used by the app.

### Video - [AppSheet REST API](https://www.cloudskillsboost.google/course_templates/390/video/320434)

- [YouTube: AppSheet REST API](https://www.youtube.com/watch?v=aJACEJ1kzDA)

Hansel: Users generally interact with your app by installing the app on their mobile devices. What if other external applications want access to the functionality that the app provides? For example, a service might need product shipment information or product inventory levels from an inventory management app in order to perform back-office operations. AppSheet provides several ways to integrate your app with external web services or applications. In this module, we discuss how you can integrate your app with external applications and services using common integration techniques involving APIs and webhooks. One of the ways that AppSheet enables integration with external applications is via the AppSheet REST API. In this lesson, we discuss how you can use this API to integrate with the data sources used by your app. The AppSheet REST API enables an external application to access the data that is used by your AppSheet app. REST stands for representational state transfer and is an architectural style used for communication between client applications and web services using APIs. By invoking the AppSheet REST API, the external application can perform the following operations: add a row in a table, find or read a row from a table, update a row in a table, delete a row from a table, invoke a predefined action in the app. To enable the AppSheet REST API, navigate to the manage integrations tab in the AppSheet UI. Expand the in from cloud services to your app section. Click enable. You use the app ID shown here in the URL to the AppSheet REST API. If a valid application access key does not already exist, click create application access key. Save your changes to the app. An application access key is an API key that must be sent by the external application in every AppSheet API request. AppSheet verifies the key to make sure it is valid and not disabled before processing the API request. If the key passed in the API request does not match any of the valid API keys, the request is rejected and logged to the app's audit history. You can create more than one application access key for the app. This is useful when you want to distribute separate keys to different external applications to control their access to the app individually. After you enable the AppSheet REST API, external entities perform the following steps to invoke the API from their applications. You should also follow these steps to test that the API works as expected for your app. First, you construct a URL. The URL to the AppSheet API must have the following part components. appId, this is the globally unique ID, or GUID, of the app. It is available in the manage integrations tab in the AppSheet UI. tableName, this is the table on which the API request will execute. Next, construct the headers and body of the request that is sent to invoke the API. One of the HTTP headers is the ApplicationAccessKey header whose value is an API key which you must replace with one of the valid keys that are available in the manage integrations tab in the AppSheet UI. Another header named Content-Type with the value of application/json is also required in the API request. In addition to the HTTP headers we just talked about, the API request also contains a POST request body in JSON format that contains the following attributes. Action is the name of the action to be performed and can be add, find, edit, delete or the name of a data change action that has been predefined for the table. Properties is an optional JSON object that contains the locale, location, user e-mail address, time zone and user settings of the user making the request. Rows contains a list of rows to be added, updated, deleted or fetched from the table corresponding to the specified action. Each row contains the column name and value of the row being added or updated. Note that for all actions, the row's key column and value must be included. You can omit the key column and value for the find action when the selector property is used. You can also omit it for the add action if the key column definition uses an initial value function or if other columns that define the key are provided. Then, send the HTTP POST request to the AppSheet API and point at api.appsheet.com. External applications would typically use a client SDK to make API calls to the AppSheet REST API. For testing purposes, you can use any REST client such as Postman or cURL. Finally, process the response from the REST API. For a more detailed specification of the API request, review the documentation on the AppSheet website. Let's now execute the steps to invoke the AppSheet REST API to retrieve information about a product from our sample application. The AppSheet REST API request has the following: the URL that contains the app ID and the name of the table from which data is required, the application access key header, the content type header, the request body that specifies the find action and the table's key column and value corresponding to the row of data to be retrieved. cURL is a popular command line tool to create and test REST API calls. We use cURL to invoke the AppSheet REST API. Here is the cURL command with the API request and a partial response from the AppSheet REST API that contains the details of the product retrieved from the table. Let's add a new product category to our catalog using the AppSheet REST API. Here is the AppSheet REST API request URL that contains the app ID and the name of the table that will contain the new product category, the application access key and content type headers as before, the request body that specifies the add action, the locale and time zone properties and the row data to be added to the table. Using the cURL command as before, this request generates the response from the AppSheet REST API as shown. The new holiday product category was added to the table via the AppSheet REST API and can now be managed in the app. The AppSheet REST API is a useful tool that makes it easy for you to programmability manage data entities that are used in your app. For more details on using the API, read the documentation on the AppSheet website.

### Video - [Apigee REST API](https://www.cloudskillsboost.google/course_templates/390/video/320435)

- [YouTube: Apigee REST API](https://www.youtube.com/watch?v=t_7ZfCBIQYA)

Person: Using the Apigee data source type, you can build apps in AppSheet using the data exposed by APIs that are managed by Apigee. In this video we discuss how you can configure your app to use Apigee as a data source. Instead of client applications connecting directly to back end systems or services, many organizations implement APIs through which client apps interact with those back end services. There are many advantages of using such a multilayered architecture. The Apigee API management platform enables you to develop and deploy APIs and provides many of these benefits including request rate limiting, security and authentication, data transformation, service orchestration, analytics and much more. To set up an Apigee data source in AppSheet, follow these steps. Navigate to the My Account page in the AppSheet UI. Then click on the Sources tab. In this tab, click New Data Source. Select Apigee. Select an option to connect to APIs that run on Apigee. We recommend that you use the open API spec option if you have an open API specification for the Apigee API in order to get read and write access to the Apigee data source. You can use the manual option if you do not have an open API specification available for the Apigee API. This option provides read only access to the Apigee data source. Note that one of the requirements for the Apigee API endpoint is that the JSON response from the API must be flattened and contain no nested arrays. With either the manual or open API spec options, select the authorization type. One type of authorization is API key, which enables Apigee to identify and validate the app that will invoke the API. The value must be generated in Apigee and entered here, or you can select the authorization type OAuth, which uses access tokens to authenticate and authorize the app to invoke the API on behalf of the app creator or user. When using OAuth, you must configure the Apigee connection with the app's client ID and client secret values that are generated in Apigee. When using the open API spec option, you must configure the connection with the URL for the open API specification. The specification is the JSON document that is based on the OAS 3.0 standard and describes the interface to the rest API that runs on Apigee. The URL to the specification is typically provided to you by the API developer and must be publicly accessible. When you use this method of connecting to an Apigee data source, the app can read and write data to the back end service via the API. When using the manual option, you must also configure the base path URL of the Apigee API proxy. This is the rest entry point that will be used by the app to invoke HTTP methods on API resources that are exposed through the Apigee API. Enter a list of comma-separated API resource endpoints. These are URL fragments that follow the base path URL of the API. Optionally set any authorization scopes that are defined for the API resources. Authorization scopes are permissions that restrict the calling app to execute specific operations of the API and a part of the OAuth token when generated for the app. If the OAuth authorization type is used, you must also provide the URL to the OAuth token generation API, which generates the OAuth access token used to access the Apigee API. Note that the manual method of connecting to Apigee allows read-only access to the back end service data. After configuring the connection, click Validate or Test to verify that AppSheet can access the Apigee API resource paths. When the tests are successful, click Authorize Access to add the Apigee data source to your app. For more information on configuring Apigee APIs as data sources, read the documentation on the AppSheet website.

### Video - [AppSheet webhooks](https://www.cloudskillsboost.google/course_templates/390/video/320436)

- [YouTube: AppSheet webhooks](https://www.youtube.com/watch?v=Lps6AFDmQ-o)

Person: Let's now discuss how you can use webhooks in AppSheet. In this video, we discuss what webhooks are and how you can use the different webhook templates available in AppSheet in your app. A webhook is an event-driven mechanism that is used to send data from one system to another using the HTTP web protocol. The receiving system provides a webhook URL that is invoked by the sending system or app whenever the event is triggered. Unlike an API, a webhook is lightweight to implement and supports one-way sharing of data between the sending and receiving systems. After the data is sent, the sending system does not wait to receive a response from the receiving system. AppSheet supports webhooks for your app to enable it to send data to external web services by using either the send and forget model or the send and wait model. In the latter, AppSheet waits for a 200 response from the receiving system before continuing and automatically retries a request if an error response is received. The number of retries is configurable. To use webhooks in your app, you create a bot that executes a process with the webhook task that posts data to a web service that supports webhooks. There are many such services like Google Chat, Zapier, Slack, Twitter, Twilio, et cetera. When an event occurs in your app that triggers the bot, the webhook task is executed, and data is sent to the webhook service. To create and use webhooks in AppSheet, you create a task using the webhook task category. Add the task as a step in a process. Create an event to trigger a bot. Create the bot for the event and configure it to run the process. Note that these steps require the use of the automation features of AppSheet. AppSheet Automation is discussed in detail in a separate course in this series. AppSheet can support any format of a webhook call. In addition, there are two built-in templates that can be leveraged for convenience, Slack Hook and AppSheet API. To post a message to a Slack channel, use a Slack Hook. Let's create one for a sample inventory management app. To create the webhook, navigate to the automation tasks tab in the AppSheet UI. To add a new task, click new task. In the new task form, for task category, select call a webhook. Provide a name for the task, for example Slack low inventory. Select the table that is used for this webhook task. For this example, we select the products table. For preset options, select Slack Hook because we are creating a webhook to post a message to a Slack chat channel. The other options currently supported are custom and AppSheet API. Based on your selection, you configure different webhook options in this section. Provide the webhook URL generated by Slack for the chat channel. This URL is generated when the app is configured in the Slack system. Provide the body of the message that is sent to Slack when this webhook executes. As discussed earlier, webhooks are run when an event occurs in the sending system. You can use AppSheet, the sending system, to trigger the webhook by creating and configuring an event in your app. You also create a process that contains a set of steps that include the webhook task and create a bot that is configured with the event and the process to execute. When the event occurs, the bot is triggered which causes the process to run and execute its tasks. You create an event in the automation events tab of the AppSheet Editor. Our sample event is configured on the products table used in our sample app for any changes to the rows in the table. The event also only occurs for rows whose current inventory value is below the minimum acceptable inventory value in the table. This is expressed as a condition for the event to fire. Next, you create a process in the automation processes tab of the AppSheet Editor. To configure the process, you first select the table on which the process executes. Then, define the process steps by providing the step name and selecting the type of step. For our sample use case, we select a task to be run as the step in the process and then identify the task by selecting the previously created Slack Hook task. Finally in the automation bots tab, we create the bot that will execute the process when the event is triggered. The bot is configured with the event and the process to execute when it runs. Now whenever a product whose current inventory is below its minimum acceptable inventory is updated in the app, a message is sent to a Slack channel via the webhook.

### Video - [Webhook to the AppSheet API](https://www.cloudskillsboost.google/course_templates/390/video/320437)

- [YouTube: Webhook to the AppSheet API](https://www.youtube.com/watch?v=PZQ2DFdi1sE)

Hansel: In this video, we discuss how AppSheet supports the use of webhooks to the AppSheet API. The following steps show how you can trigger a change within the same application. For example, when a product shipment is canceled or deleted from the shipping table in our sample app, we may want to automatically update the product's current inventory to reflect the number of units that no longer need to be shipped. In the automation task tab of the AppSheet editor, click new task. For task category, select call a webhook. Provide a name for the task, for example, update inventory. Select the table that is used for this webhook task. For this example, we select the shipping table. For preset options, select AppSheet API. The app's app ID is automatically selected. For target table name, select products. Both the app ID and target table name are required in the URL to the AppSheet API. Specify the body of the HTTP request that is sent to the webhook receiving system, in this case the AppSheet API. Because we need to update a row in the products table, our webhook request body contains the action type edit, the locale and time zone properties, the row to update. This is identified by the value of the key column name, product ID, whose value is provided by a template variable. AppSheet dynamically substitutes the value of the product ID using the reference from the current row in the shipping table. Additional columns to update, in this case we are updating the current inventory column by incrementing its current value by the number of units no longer being shipped from the current row in the shipping table. This number is stored in the shipping table's quantity shipped column. Specify any HTTP headers required by the AppSheet API service. These headers are sent in the webhook request. The value of the header must be enclosed in quotes. Note that if you're invoking the API for an app that you do not own, you must specify the application access key header here. Instead of specifying the webhook request body in line as described above, you can use a webhook template and specify the template's file ID in the body template field. A webhook template is a text file that is stored on your cloud provider, for example Google Drive, and contains the webhook request body in JSON, HTML or CSV format. You use variables and expressions in the body template that AppSheet evaluates and automatically substitutes with values when the webhook request is made. If a body template is used, specify the body template data source. AppSheet automatically populates this field based on the cloud provider used to store the template file. After the task is created and saved, we create a data change delete event on the shipping table using the steps outlined earlier and create a process to execute the webhook task. Finally, we create the bot that is triggered by the event to run the process and save our changes to the app. Now, when a shipping transaction for a product is deleted via the app, the bot is triggered and executes the task to invoke the AppSheet API via the webhook. The product's inventory level is updated to include the number of units no longer being shipped.

### Video - [Custom webhooks](https://www.cloudskillsboost.google/course_templates/390/video/320438)

- [YouTube: Custom webhooks](https://www.youtube.com/watch?v=fekFoZoyuBw)

Person: In this video, we discuss how AppSheets supports the use of custom webhooks for your app. Create a custom webhook in AppSheet following the same general process outlined in the previous video. To create a custom webhook, for example, to send a notification to a space in Google Chat, follow these steps: Create a new task and set the task category to call a webhook. Give the task a name; for example, Google Chat Low Inventory. Select the table that the task will run against. Set the preset as Custom. Provide the URL to the webhook service that will receive the request. For this example, it is the Google Chat incoming webhook URL. You create the webhook in the Google Chat web application to generate this URL. Specify the HTTP verb; Put, Patch, Post or Delete. This indicates the type of operation to be performed on the receiving service. Put and Patch are used to update a resource. Delete is used to delete a resource. And Post is used to create a new resource. Specify any HTTP headers required by the receiving service. Specify the body of the webhook request. As discussed in the previous video, after the task is created and saved, you create a process to execute the task. Then, create an event that is used to trigger a bot that executes the process. And finally, create and configure the bot with the event and the process. When the bot fires, a message is sent to the Google Chat space via the AppSheet webhook. You can configure these execution options for a webhook in AppSheet; Timeout -- the number of seconds the AppSheet waits for the webhook call to complete. Default is 180 seconds. Max number of retries on failure -- the number of times an AppSheet should retry the webhook if it fails or times out. The default is three. Run asynchronously -- if enabled, this option instructs AppSheet to run the webhook asynchronously in the background and immediately return from the task.

### Video - [Lab: Integrating Your AppSheet App with External Services](https://www.cloudskillsboost.google/course_templates/390/video/320439)

- [YouTube: Lab: Integrating Your AppSheet App with External Services](https://www.youtube.com/watch?v=fRmBRArr03c)

person: We now invite you to take two labs on the topics discussed in this module. In the first lab, you'll learn how to... In the second lab, you will learn how to... To do these labs, click the link provided on the learning platform.

### Lab - [Integrating Your AppSheet App with External Services](https://www.cloudskillsboost.google/course_templates/390/labs/320440)

In this lab, you'll use AppSheet to integrate your app with external service providers.

- [ ] [Integrating Your AppSheet App with External Services](../labs/Integrating-Your-AppSheet-App-with-External-Services.md)

### Lab - [Using Cloud SQL as a Datasource for Your AppSheet App](https://www.cloudskillsboost.google/course_templates/390/labs/320441)

In this lab, you use AppSheet to connect and configure data for your app using Cloud SQL as a datasource.

- [ ] [Using Cloud SQL as a Datasource for Your AppSheet App](../labs/Using-Cloud-SQL-as-a-Datasource-for-Your-AppSheet-App.md)

### Quiz - [Quiz](https://www.cloudskillsboost.google/course_templates/390/quizzes/320442)

#### Quiz 1.

> [!important]
> **What types of webhooks are currently supported in AppSheet? Select three.**
>
> - [ ] Custom webhook
> - [ ] AppSheet API webhook
> - [ ] Slack Hook
> - [ ] User webhook

#### Quiz 2.

> [!important]
> **What can the AppSheet API be used for? Select three options.**
>
> - [ ] The AppSheet API enables an external application to access the data used by an  AppSheet app.
> - [ ] The AppSheet API can be used to invoke a predefined action on an app.
> - [ ] The AppSheet API can be used to read, update, add, and delete rows from a table used by the app.
> - [ ] The AppSheet API can be used to invoke an API running on Apigee.

#### Quiz 3.

> [!important]
> **To invoke the AppSheet API, which items must the calling application send in the request? Select four.**
>
> - [ ] Table name
> - [ ] Application ID
> - [ ] ApplicationAccessKey
> - [ ] Content-Type
> - [ ] View name

#### Quiz 4.

> [!important]
> **Which AppSheet components are required to create a webhook for an app? Select four.**
>
> - [ ] Trigger
> - [ ] Event
> - [ ] Task
> - [ ] Bot
> - [ ] Process

### Video - [Module Review](https://www.cloudskillsboost.google/course_templates/390/video/320443)

- [YouTube: Module Review](https://www.youtube.com/watch?v=U8BuMa9c3gQ)

PERSON: Congratulations on completing this module on AppSheet integrations. Let's do a quick review. In this module, you learned how the AppSheet REST API can be used to integrate external applications with the data sources used by your app and how you can configure your app to use an Apigee REST API as a data source. We also discussed webhooks, and you learned how to configure and run webhooks for your app using AppSheet's automation features.

## Advanced App Design

Improve app scalability and performance with security filters and data partitioning.

### Video - [Data scalability](https://www.cloudskillsboost.google/course_templates/390/video/320444)

- [YouTube: Data scalability](https://www.youtube.com/watch?v=sSHwkk9jvQQ)

Person: Welcome to the module on Advanced App Design. In this module, you will learn about app scalability and the practices you can use in AppSheet to improve the performance of your app. We also discuss how to support multiple languages in your app, and techniques to collect user feedback about your app. Let's start by discussing how you can improve the performance of your app by using techniques, like partitioning and security filters, that improve the data scalability of your app. Data scalability refers to the performance of your app when the data it uses grows and becomes large. App creators should consider how their apps perform and design their apps to scale while supporting large datasets. There are also physical limitations on the number of rows or cells that can be stored in certain types of data sources. For example, Google Sheets limits its spreadsheet to five million cells, and Smartsheet limits a single spreadsheet to 20,000 rows. There are two app usage patterns to consider when working with large datasets; non-partitionable and partitionable. The non-partitionable app pattern is used when each user needs access to all the data in the large dataset. For example, an inventory management app that manages a large number of products and their related data may need each user to manage all products in the app. The partitionable pattern involves a large number of data rows, but each app user only accesses a smaller subset of the rows. For example, a project management app may be used to manage a large number of projects and their tasks for an organization. Only project team members working on specific projects need to access a subset of projects and their tasks. You can scale partitionable apps easily and effectively by using security filters and data partitioning. Before we discuss these scaling techniques, it's useful to understand how AppSheet makes data available to the app. There are three steps involved when fetching app data; one, from the cloud data provider to the AppSheet server. When an app starts and fetches data from AppSheet, the AppSheet server must first retrieve that data from the cloud data provider server. This data can be from a spreadsheet, database or API. Two, from the AppSheet server to the app. Next, the data is sent from the AppSheet server to the app that is running on a user's mobile device or desktop browser. And three, storing the data on the device. Finally, the app stores the data locally on the device. This enables the app to work seamlessly when offline, or on a low bandwidth network. Let's review how you can scale your app using security filters. Security filters are yes-no expressions that are associated with each table in the app, and use the user's email address and other data values to limit the data shown to the app user. Security filters were discussed in a previous module in this course. When you scale your app with security filters, the data is filtered during or after step one, so you can reduce the data that is used in steps two and three. Please note that when you use a spreadsheet in your app, the entire sheet is fetched in step one. When you use a database, the data is filtered during step one at the database layer, which can lead to significant performance improvements in your app. Security filters are primarily meant to be a security feature, but they can also be used to improve an app's scalability. The most common filter returns rows from a dataset that are relevant to the app user. For example, where the owner of the rows matches the email of the signed-in user. In the example shown, if the user uses the email address E2@company.com to sign into your app, you can use a security filter to return row from a team project table that only matches the user's member ID. These rows contain data of the projects that the user is currently a member of. When you use database tables in your app, AppSheet attempts to apply security filters to the database as SQL queries, provided the filters can be mapped to efficient queries. AppSheet applies security filters to the database as SQL queries for the following database providers; MySQL, Microsoft SQL Server, MariaDB, Oracle, Postgres and Redshift. To ensure that a security filter maps to an efficient database query, try to reduce it to a simple comparison of a column to a value, using comparison operators and expressions. Compare a column's value with a list of values using the IN function, and use an AND condition with simple comparison expressions. Most other conditional expressions will probably not be applied as database queries. But AppSheet does attempt to apply partial expressions where possible. For example, the condition shown using a simple first expression where column 1 equals 5 -- that will be applied to the database query, but not the second. Let's now discuss how you can use data partitioning to scale your app. In this approach, the data is divided into identical partitions that have the same column structure, with each partition containing a different sublet of the rows of data. Each user gets data from a specific partition at any given time when using the app. This technique can be used along with security filters and enables the app to scale efficiently. Let's review how to use data portioning through an example. To illustrate how data partitioning can be implemented in your app, we'll use a simple project management app that allows users to manage tasks in a project. We'll use the following data sources for our sample app: Projects -- a spreadsheet containing all the projects that are managed by the app, and Tasks -- a spreadsheet that contains the tasks for each project. To use data partitioning for this app, do the following: Partition the task spreadsheet to split the tasks into separate data sources by project. The tasks can be split into multiple spreadsheets or into multiple worksheets in the same workbook. The sample shows the contents of the Project 3 tasks worksheet. Note that the column structure in all sheets must be identical. In our sample app, we used two tables to store employee information and project team membership. Add the Teams and Employees tables to our sample app. AppSheet automatically determines the relationship between these tables and the Projects table, and configures the corresponding columns as Type Ref. Provide a partition expression that enables AppSheet to determine which task worksheet or workbook to use for a given app user, based on the project they are currently working on. The partition expression identifies a specific partition for each user based on the user email or user settings' values. To use a partition expression, expand the Tasks Table definition in the Data Tables tab in the AppSheet editor. Expand the Scale section. Because the tasks in our sample app have been partitioned into multiple worksheets, enable the Partition Across Many Worksheets option. For the partition expression, use the Expression Assistant to type an expression that returns the project ID that the signed-in app user is a member of, based on their email address. Then specify the data partitions by identifying each worksheet, using the worksheet name in the Tasks workbook, and using the project ID value that is returned by the partition expression. Save your changes to the app. Now when an app user signs into the app, the app only fetches the task's data from the AppSheet server that corresponds to the project that this user is a member of. This makes the app highly performant when there are a large number of projects and tasks. It also limits the amount of data transferred from the AppSheet server to the user's device. Please note that the partition expression uses the ANY function to select any one project ID from the Teams table. This works as expected when the user is a member of one project, or works on one project at a time. But what if you wanted a user who may belong to more than one project to be able to select a specific project to manage its tasks in the app? To implement this capability where the user has the ability to dynamically update the filter in the app, use AppSheet's User Settings feature. This feature is discussed in the next video of this lesson. Now that you know how to partition your data to improve your app's performance, let's discuss the pros and cons of this technique. Data partitioning is a powerful mechanism to scale your app while keeping your data in the format of familiar spreadsheets, like Google Sheets, Excel or Smartsheet. The amount of data transferred over the network between the app and the AppSheet server is reduced, and the amount of storage needed by the app to store this data on the user's mobile device is also reduced. When using data that must be stored separately, for example for example for client data, partitioning provides a convenient solution to maintain and distribute a single app while still allowing each user to view and manager their own data using the same app. The disadvantages of using data partitioning are, because the data is divided into several physical sheets, you might create extra management overhead for data maintenance and reporting. It's important that all the partitions have an identical column structure. Because AppSheet cannot guarantee this behavior, this becomes an additional responsibility for the app creator. To summarize, in order to scale and improve the performance of your app, you can use security filters, implement data partitioning and use database sources with efficient filters that can be mapped to database queries. Non-partitionable apps can be difficult to scale because all the data must be accessible by each user, all data rows must be fetched and moved through all three data transfer steps discussed earlier. This will cause the app's performance to degrade as the dataset scales.

### Video - [AppSheet user settings](https://www.cloudskillsboost.google/course_templates/390/video/320445)

- [YouTube: AppSheet user settings](https://www.youtube.com/watch?v=YPcYrYmbwkU)

Person: The user settings feature in AppSheet allows the app user to customize the behavior of the app by changing the setting of certain options in the app. In this video, we discuss how you can implement this feature in your app. As an app creator, you define the options whose settings can be changed by the app user. You then use these options and expressions that are used in security filters, slice filters, app formulas and initial values, column constraints, format rules, et cetera to control the behavior of the app. To define your user settings, navigate to the data user settings in the AppSheet Editor and click to expand the per user settings panel. Here, an app creator can change the names, types and other properties of one or more user settings that are displayed in the app. Let's now modify our project management app from the previous topic to enable an app user to switch between multiple projects in the app. To enable the user settings for our sample project management app, implement the following changes. In the data user settings tab in the AppSheet Editor, expand the per user settings section. Configuring user settings is similar to defining the columns of tables that are used by your app. Because we want the app user to select the project to work on, we update the first option's main property to projects. To enable the app user to select a project from a list, change the type of this option to enum. Enable the show and editable properties. Edit the option definition by setting the base type to ref. Then set the reference table name to projects. This will populate the list in the enum with values from the projects table using the key ID column and the name label column. Set the input mode to buttons. Provide a valid If expression that returns the list of project IDs based on the e-mail of the signed-in user. Expand the autocomplete section and enter the same valid If expression wrapped in an Any function for the initial value. This expression is used to set the initial value of the project's option to one of the valid project IDs that the signed-in user has access to. Click done and save to save the changes to the app. Finally, you must modify the partition expression for the task table to load the correct worksheet based on the app user settings of choice of project from a settings page in the app. To do that, navigate to the data tables tab and select the tasks table. Expand the scale section and set the partition expression to user settings projects. This expression will return the current value of the project option as set by the app user. There is no change needed to the partition's definitions. Save your changes to the app. The app preview now shows the settings menu item in the app's main menu. Clicking on settings opens the user settings page in the app with the projects options along with a list of projects as buttons. Now when the app user changes the project settings to select a specific project, the app refreshes to load only the tasks for that project. There are many use cases where you may want to implement user settings in your app. For example, if your app manages information for multiple countries, you can let the user select a country via the user settings and then filter the data using security filters or slices to display only the information for the selected country. To tailor the app's user interface based on the language preferences of users, enable them to select a language option from the user settings. For more details on user settings, refer to the documentation on the AppSheet website.

### Video - [Lab: Using Data Partitions with Your AppSheet App](https://www.cloudskillsboost.google/course_templates/390/video/320446)

- [YouTube: Lab: Using Data Partitions with Your AppSheet App](https://www.youtube.com/watch?v=QLnKxNc36wk)

PERSON: We now invite you to take a lab on some of the topics discussed in this module. In this lab, you'll learn how to create security filters to limit the data used by your app, partition the data in separate worksheets and configure your app to use the data partitions, enable your app to support user settings, and apply the user settings to control access to the partitioned data in the app. To do this lab, click the link provided on the learning platform.

### Lab - [Using Data Partitions with Your AppSheet App](https://www.cloudskillsboost.google/course_templates/390/labs/320447)

In this lab, you'll use AppSheet to partition the data that is used by your app.

- [ ] [Using Data Partitions with Your AppSheet App](../labs/Using-Data-Partitions-with-Your-AppSheet-App.md)

### Video - [App performance](https://www.cloudskillsboost.google/course_templates/390/video/320448)

- [YouTube: App performance](https://www.youtube.com/watch?v=JWPnUUPJGIc)

Katelyn: In this video, we discuss the synchronization process and how it affects app performance. You'll learn some of the techniques to improve the performance of the sync process for your app and also about the profile or performance tool in AppSheet that helps you understand and analyze the performance of your app. So what does app performance mean in the context of AppSheet apps? It usually means how responsive the app is as experienced by the end user of your app. The time spent by users waiting for an app to refresh or to provide a response to a function within the app is referred to as latency. It is defined as the time a system takes to initially respond to a request. App responsiveness and latency are directly related. The goal is to minimize the latency for your app in order to make it highly responsive and perform well. Throughput is also a term used in relation to app performance and latency. It is defined as the amount of data that can be transferred per second between the various systems involved with AppSheet. This includes the app, the AppSheet server and the cloud data provider. The AppSheet sync process has an impact on the performance of your app. Let's review how the app sync process works in AppSheet. As discussed previously, your app communicates to the AppSheet back end service, AppSheet server, which acts as an intermediary that communicates with your cloud data provider. It's helpful to consider the sync process in terms of reads and writes from the app to the cloud data provider via the AppSheet server. Let's review the sync process for reads. Step one, when the app on the mobile device starts up or initiates a sync, it requests data from the AppSheet server. Step two, the AppSheet server in turn requests data from the cloud provider. Note that in this step, the AppSheet server may have to fetch many tables from the same or different cloud providers. Step three, after the AppSheet server receives the data from the cloud provider, it computes any virtual column formulas. And in step four, the AppSheet server then returns all of the data to the app that is running on the mobile device where the app stores the data. Let's now review the sync process for writes. When an app that has made some data changes to its local data copy invokes the sync process, the following steps occur. Step one, the app sends each of the added, updated and deleted data rows to the AppSheet server. Any photos, drawings or signatures are sent along with the data rows. Step two, when the AppSheet server receives this information, it writes the data to the cloud provider. Steps three and four, after the write steps are completed, the read sync process is then executed by the app to fetch the updated data. Please note that the AppSheet server may also execute a separate read of the updated data if required. Focusing on improving your app's sync performance will positively impact the end users of your app. Let's review some of the steps you can take to improve the read sync process of your app. You can improve the read sync process by reducing the amount of data transferred during sync. To reduce the amount of data transferred between the app, the AppSheet server and the cloud data provider, you can delete empty rows and empty columns from your worksheet, including any empty rows at the bottom of the worksheet or any empty columns to the right of the worksheet. If your worksheets contain many empty rows or columns, you can greatly improve performance by deleting them. Ensure that there is no unnecessary data in the spreadsheet workbook. Only include worksheets that the application requires and remove the rest. Extra worksheets will add overhead when fetching the requested data, and any changes to those worksheets interfere with caching optimizations. Enable AppSheet to more easily cache read-only tables by placing them in their own workbook. This also helps AppSheet to accurately track whether the data in the workbook has been updated. Use security filters to eliminate rows that do not satisfy filter conditions. Use partitioning to divide large data sets into different partitions where the data from each partition serves a subset of app users. Enable server caching to allow the AppSheet server to maintain cached copies of read-only tables for up to 5 minutes. If your app depends on data that doesn't change often, you should enable this option. Enable the Delta sync option to maintain time stamps for the last time each table was fetched. On each sync, the AppSheet server tries to determine whether the table has been updated after the time stamp and only then retrieves table data from the cloud data source. You can also improve read sync performance by reducing the amount of computation performed. Computations happen during the sync process at two places. The first is in spreadsheet formulas. Long-running formulas can cause significant delays and, in extreme cases, even time-outs when you use AppSheet. And in AppSheet virtual columns, virtual columns in a table are defined by app formulas and are computed by the AppSheet server on every sync. App formulas are very powerful and expressive, but you must make sure to avoid using inefficient ones. To reduce the amount of computation during sync, you can ensure that the spreadsheet only uses simple formulas, avoid cross-sheet formulas and those using external services that are likely to severely impact sync performance, minimize use of worksheet formulas that must be recomputed by the AppSheet server each time the worksheet is read. Another way you can improve the read sync performance is by fetching or computing data in parallel from the AppSheet server. An app typically has multiple tables whose data is fetched by AppSheet in parallel from the data source. However, because this is a resource-intensive activity and is limited by the number of concurrent threads available, the degree of parallelism in AppSheet is controlled by the app owner's subscription plan. To improve the read performance of the app sync process, you should balance the need for data freshness in the app with sync latency as perceived by the end user. With all sync options disabled, the default behavior of the app is to sync immediately if a row is added, updated or deleted by the app. As the app creator, you can control sync behavior using the following options for your app. Enable sync on start to force the app to sync every time it is restarted. This is a good mechanism to limit the staleness of the app's data. Enabled delayed sync to queue updates instead of syncing them immediately. Use this option for apps that are used in remote regions with limited or no network access. When the user returns to an area with good network access, they can explicitly click sync to sync all queued updates to the back end. However, note that the longer the time between syncs increases the possibility for data conflicts because someone else may have updated the same data. Enable automatic updates for apps in environments where there is good network connectivity. Any updates made by the app immediately trigger a sync in the background while the user continues to use the app. If there are no updates made by the app, the system will still periodically run a sync to ensure that it has the latest data. Note that this option will increase use of the device's battery, network and server resources and possibly run more syncs than are necessary. The impact must be balanced against the benefit of having an app that is always close to up-to-date without users needing to explicitly sync the app. Data captured or updated by the app on a device is sent via the AppSheet server to the cloud provider. To ensure correctness, the sync process makes these changes sequentially and therefore is slow and time consuming. There are a few ways to improve the sync performance for writes or updates. You can design the app in a way that reduces the number of updates. For example, using a form to update multiple columns of a table row requires a single update transaction versus using the quick edit feature that would create multiple update transactions, one for each column to be updated. Quick edit is an AppSheet feature that allows you to mark specific columns of a table to be editable directly from the detail view in the app. You can also try to reduce the amount of data sent with each update. Rows that involve images add significantly to the amount of data sent per update. Uploading images at a higher resolution increases the amount of data transferred during sync. You can control the resolution of uploaded images via an option in the UX options tab. You can also improve the write sync process by reducing the amount of computation that must happen with each update. When an update is synced, data is computed from two sources. The first is spreadsheet formulas. For example, Google Sheets will recompute all affected spreadsheet formulas on every single update, so any expensive formulas like computing aggregations across all the entries in the spreadsheet can increase the time it takes to complete the update. And the second source is data update automation tasks. On every update, the workflow rules in your app must be evaluated. Depending on the logic in the rule condition and rule action, this could add significant overhead. For example, workflow rules that make data changes to other rows can add significant overhead to each update that is synced. And finally, you can apply data updates in the background so that the app user does not need to wait for them to complete. You can do this by turning on automatic updates in the offline sync tab in the AppSheet Editor. The AppSheet platform provides a profiler performance tool that can help you to understand, analyze and improve your app's performance. To access the tool and check the performance profile of your app, in the AppSheet Editor, navigate to the manage monitor tab. Click performance profile and then click launch performance analyzer. Look for appropriate performance log records. Click the performance icon to see the performance details of the action. Review the performance details of a transaction and consider implementing any recommended actions to improve app performance. You must be aware of other factors that can affect the interactivity and responsiveness of your app on a device. We've already discussed how the sync process can impact the performance of your app. Large data sets can consume a lot of device memory which leads to delays in the rendering of the app's UI. We discuss managing large data sets in the next video. Complex data format rules can also involve a lot of computation each time a screen is scrolled, affecting interactivity of the app.

### Video - [Using large datasets](https://www.cloudskillsboost.google/course_templates/390/video/320449)

- [YouTube: Using large datasets](https://www.youtube.com/watch?v=X3Xlb9_LJAk)

Person: Using large data sets can impact the performance of your app. In this brief video, we discuss guidelines for using such data sets with your app. When designing and developing your app, you should be mindful of the size of the data sets that will be used by the app. When an app performs a sync the data is copied from the data set on the cloud provider to the user's device via the AppSheet server, allowing the user to easily interact with the data inside the app. Using large data sets can effectively result in long sync times when the app is initially loaded on the end user's device. So what makes a large data set? It's difficult to accurately define a large data set. However, consider the following guidelines with respect to the data size limits mentioned here. A file's compressed data size depends on how the file is populated with data. For example, a large spreadsheet with a lot of empty cells will probably compress better than a smaller spreadsheet with no empty cells. An AppSheet app currently has a compressed data size limit of 5 megabytes or 10 megabytes, depending on the device, for all the data used by the app. Images and documents are not included in the data size limit. They are not cached locally on the device by default. If you enable this option to cache images for offline access, they are stored in a different location on the device that does not have the same size limitations. In general, fewer cells in a spreadsheet produce better results. Each spreadsheet provider has its own limitations based on performance, file size, number of formulas and calculations. You should consider these limitations as you build your app. For example, a sheet on Google Drive can contain a maximum of 5 million cells. Refer to your cloud data provider's documentation for these limits. There is currently no limit on the number of tables that can be used in an AppSheet app. As a benchmark, complex apps can have between 20 to 30 tables, but you should consider the following when using a large number of tables in your app. App performance degrades as the number and size of the tables grow. App performance also degrades when tables are stored in separate spreadsheet files. The biggest determinate of performance is the number of times AppSheet must access the cloud provider, such a Google Drive, to fetch a file. Here are some guidelines to use when building your app, keeping in mind the app's performance. Limit your app to a few tables and views. Design and create your apps with focus by implementing functionality in the app for a specific purpose. Within an app, use AppSheet's capabilities that have been previously discussed to improve performance: user settings, security filters, slices and data partitioning.

### Video - [Multi-language app support](https://www.cloudskillsboost.google/course_templates/390/video/320450)

- [YouTube: Multi-language app support](https://www.youtube.com/watch?v=08z0jsAMNdM)

Person: In this video, you'll learn how to offer users the ability to select their preferred language in your app and how to customize the column names and text on buttons and icons that are displayed in the app to match the user's language preference. There may be a requirement for you to support multiple languages in your app, depending on the app's user audience. Adding multilanguage support in your app involves these general areas: determining the user's choice or preference of language to use in the app, using the app user's preferred language choice to display column names, display and save table data and display system text on buttons and icons. There are a couple of ways in which you can determine the user's language preference in your app. Use a table that stores user information including language preferences, or use the User Settings feature of AppSheet to allow the app user to select their language preference within the app. After the language preference is set, you can use it in expressions to control the values displayed for column names, column data and system text in the app. Let's review how to implement this capability in our sample app using AppSheet's User Settings feature. As discussed earlier in this module, the User Settings feature allows the app user to customize the behavior of the app by changing the settings of certain options in the app. As the app creator, you define the options whose settings can be changed by the app user. In the AppSheet editor, navigate to Data User Settings. Expand the Per User Settings panel. Enable the Show Property for the language option. Change the name of the option to language. To edit the option definition, click the pencil icon next to the language option. Provide the language values for this [Indistinct] type, and click Done. Then click Save to save your changes to the app. The app user can now use the Settings option in the app's main menu to display the app's language choices and select their preference. They then click Save to save their preference in the app. As the app creator, you can now use the user-selected language preference in expressions to dynamically modify display names and system text and also use different data sheets in the app. Let's review how you can dynamically set the display name of a column based on the app user's language preference setting. We use the Product Name column in our Products table to demonstrate this. Navigate to the data columns tab in the AppSheet editor, and expand the Products table definition. Edit the product name column definition by clicking the pencil icon to the left of the column name. In the column definition form, expand the display section. In the display name field, click the flask icon to open the expression assistant. In the expression field, type the expression shown. The expression uses the switch function to return a value for the column's display name based on the user's language setting. Then click Save to save the expression and the changes to the app. To translate the names of all the columns that are displayed in your app, you must repeat the steps we discussed previously for each of the other columns. When the app user selects a different language setting, the columns like the product name and product category shown here are displayed with their localized column display names. Let's now review how you can display table data in the app user's preferred language. To determine the app user's language preference, we'll use the same technique of using the User Settings language option as discussed earlier. To display table data in a different language in the app, you must first have the data stored in that language. In our sample app, we store the products table in a separate work book, one for each language. Here is the product sheet with the product name column values in French and the price amounts in Euros. Here is the product sheet with the product name column values in Spanish and price amounts in Euros. In order to use these sheets in our app, we must configure our product's table with partitions, one for each language that is supported by the app. Note that we are simplifying the use of the language selection to also infer the user's locale. To configure the partitions, follow these steps. Navigate to the Data Tables tab in the AppSheet editor, and expand the Products table definition. Then expand the scale section. Since our Products data exists in multiple spreadsheets or workbooks, enable the Partitioned Across Many Files and Sources option. For the partition expression, use the User Settings function with the Language Option parameter. This function returns the value of the user's language setting in the app. For each value of the language setting, specify the source to use as the name of the spreadsheet or workbook that contains the product data in each language. Once configured, save the changes to the app. Now when an app user selects the French or Spanish language setting, the product data is updated to show the product names and price in the selected language from the corresponding spreadsheets. Note that, for the purposes of demonstrating this feature, we are simplifying the use of the user's language selection to also control the display of certain columns like price so that they are displayed with the appropriate currency symbol in the app. The third area where you can add multilanguage support is when displaying system text on buttons and icons in the app. You can implement this capability fairly easily in the UX localized tab in the AppSheet editor. Here, you can provide static text or an expression that evaluates the text that is to be displayed in the app. For example, to localize the text Share Based on the User's Language Preference, we use the expression shown. We can also use a similar expression for the text About and for the text Feedback. Now, after a user selects the user preference, these terms will be displayed in that language in the app. As shown in the app previous, the terms Share, About and Feedback configured earlier are all displayed in the app's main menu in the chosen language.

### Video - [App user feedback](https://www.cloudskillsboost.google/course_templates/390/video/320451)

- [YouTube: App user feedback](https://www.youtube.com/watch?v=l2J5A7OczQM)

Person: In this video we review how you can enable your app users to provide feedback about your app. Collecting and responding to user feedback about your app helps improve your app's functionality, increases its usage and popularity and helps make your app successful. AppSheet makes it easy for the app creator to receive and collect feedback from end users of the app. One way you can request user feedback is by sending feedback requests through the AppSheet editor. To enable this feature for your app, navigate to the UX options tab in the AppSheet editor. Expand the systems button section and enable the allow users to provide feedback option. Then, save your changes to the app. With this option enabled, the app user can provide feedback by clicking on the feedback menu item in the app's main menu, typing the feedback message in the pop-up window in the app and clicking done when completed. Once the app user submits the feedback, the app creator receives an email that contains the feedback message. Another approach to collect user feedback is to create your own form in your app. The form you create can have a structured feedback format based on your requirements. When users submit the form, the data is stored in the table or sheet which you can then analyze for further action. To aid in this process, AppSheet includes a feature called broadcast notifications. As an app creator, you can send a notification to your app users with a link to the app's feedback form to remind them to provide feedback. You can also use this feature anytime you want to send a push notification to the app user's device. To send a notification, navigate to the manage broadcast notifications tab in the AppSheet editor. In the form, fill in the fields for title, a few words that summarize the notification, body, a sentence to describe the notification message and deep link, an optional link to the feedback form in the app that is loaded when the user taps the notification on their device. Then click send notification to send the notification.

### Quiz - [Quiz](https://www.cloudskillsboost.google/course_templates/390/quizzes/320452)

#### Quiz 1.

> [!important]
> **How are user settings used in AppSheet? Select three.**
>
> - [ ] They are accessible from Settings, which is always available in the app's main menu.
> - [ ] They are configured just like table columns in the AppSheet editor.
> - [ ] They are used in expressions with the USERSETTINGS() AppSheet function.
> - [ ] They allow app users to select their option preferences in the app.

#### Quiz 2.

> [!important]
> **What is a partition expression in AppSheet used for? Select two.**
>
> - [ ] To identify a specific workbook of a partitioned dataset
> - [ ] To select a subset of the columns in a dataset
> - [ ] To identify a specific worksheet of a partitioned dataset
> - [ ] To partition a dataset

#### Quiz 3.

> [!important]
> **Data partitioning is a technique used to improve the performance of an app when it uses large datasets. To implement data partitioning in AppSheet, what steps must you take? Select three.**
>
> - [ ] Store each data partition in separate files or worksheets with the identical column structure.
> - [ ] Store a different subset of the data columns and rows in each partition.
> - [ ] For each app user, provide access to the data from a specific partition.
> - [ ] Store a different subset of the data rows in each partition.

#### Quiz 4.

> [!important]
> **What actions are performed when data is fetched and stored via an app in AppSheet? Select three.**
>
> - [ ] The AppSheet backend server fetches the data from the cloud provider.
> - [ ] The app stores the data on the user's device.
> - [ ] The app running on the user's device fetches data from the AppSheet backend server.
> - [ ] The correct permissions are set on the data files stored on the cloud provider.

### Video - [Module Review](https://www.cloudskillsboost.google/course_templates/390/video/320453)

- [YouTube: Module Review](https://www.youtube.com/watch?v=AT17Q1ctWiY)

PERSON: Congratulations on completing this module on advanced app design. Let's do a quick review. In this module, we discussed how you can use techniques like data partitioning and security filters to improve the scalability and performance of your app. You learned how to define user settings to enable the app user to dynamically apply security filters in your app. You learned about the AppSheet synchronization, or sync process, and how it affects that performance and techniques to improve the performance of the sync process for your app. We reviewed guidelines for using large data sets with your app. And you learned how to support more than one language in your app to display column names, column data, and system text. Finally, you learned how to enable users to provide feedback via the app using AppSheet's user experience options or by creating your own feedback form in the app.

## Managing Your App

Perform management functions like versioning, upgrading, monitoring and authoring your app.

### Video - [Versioning your app](https://www.cloudskillsboost.google/course_templates/390/video/320454)

- [YouTube: Versioning your app](https://www.youtube.com/watch?v=AOUwYoT8gzE)

Katelyn: Welcome to the module on Managing Your App with AppSheet. During your app's life cycle, you will enhance and upgrade your app to introduce new features. This module discusses how you can manage versions of your app and upgrade and restore your app to different versions while your app is being used. You will also learn about AppSheet's monitoring and auditing capabilities and how to collaborate with your team when developing your app. Let's first review versioning in AppSheet. As the creator and owner of your app, you can make changes to the app definition at any time. In this video, you will learn about versioning your app and how to implement changes and new features in a new version of your app without affecting existing app users. Every time changes to the app are saved in the editor, AppSheet saves the app's current version in a version history log. These changes include those that you make explicitly and those that are made automatically by the system when it checks the consistency of your application. To view the version history of your app, navigate to the manage versions tab in the AppSheet Editor. Expand the version history panel and click get version history. Each entry in the version history log contains the version number, the date and time the version was saved, the account ID of the person who saved the version or system for system changes, the source of the changes, the context of the changes and the actual changes made in the version viewed by clicking expand. To view a previous version of the app, click on view for a specific version entry in the version history log. Clicking on view opens the app in read-only mode in a separate browser tab. The app preview also loads, but note that if the underlying structure of the data source has changed in the newer version, the app might not run the preview. When upgrading your app, you should be aware of the following. The current version of the app in the editor is displayed in the version history section. It is also displayed in the app property section of the info properties tab in the AppSheet Editor. The version number consists of a major version number to the left of the decimal point and a minor version number to the right of the decimal point. AppSheet automatically increments the minor version number every time your changes to the app definition are saved in the AppSheet Editor. The major version number is updated when you upgrade your app. You can also manually increment the major version number in the app properties section. We discuss how to upgrade your app in the next video in this module. By default, all app users work with the latest version of your app. Any changes you make to the app definition are usually immediately visible to all app users. App users can also retrieve the latest version of the app manually by using the app sync function. In some situations, you might prefer to work on certain app changes without affecting the existing users of your app. To help you do this, AppSheet provides a mechanism called the app stable version which is available with the AppSheet Enterprise plan. To designate the current version of your app as a stable version, navigate to the manage versions tab in the AppSheet Editor and expand the stable version section. Click the button to make the current version the new stable version. After the stable version of the app is created, you can continue making further changes to your app and saving it as the latest version. To assign specific users to the stable version of your app and other users to the latest version, click the share icon in the AppSheet Editor. In the share app dialog, set the app version drop-down to the stable or latest version of your app for a given user. Note that by default, an app is set to the latest version for all users. You can also control the rollout of the latest version of your app to a percentage of the users who are not explicitly assigned a version. To do this, set the stable version of the app in the stable version section in the manage versions tab. Set the rollout percentage number field and click update the latest version rollout. In the example shown, 5 percent of all users who are not explicitly assigned a version will be assigned the latest version while the remaining 95 percent are assigned the stable version of your app.

### Video - [Upgrading your app](https://www.cloudskillsboost.google/course_templates/390/video/320455)

- [YouTube: Upgrading your app](https://www.youtube.com/watch?v=viDtFHNNIQk)

Person: As the needs of your app evolve, you might eventually need to develop a major new version of the app. In this video, you'll learn how to upgrade your app to a new version and seamlessly switch your app users to the new version after it is deployed. You'll also learn how to restore your app to a previous version. The new version of your app might have a different data structure and user experience from the current version of the app. Therefore, you might want to keep your app users on your current, or stable, version until the new version is ready for deployment, and then seamlessly switch them over. To upgrade your app, follow these steps: Make a copy of your app. To copy an app in the MyApps page of the app sheet UI, click the three dots menu on the app, and then click Copy. In the Clone Your App dialog, update the app name and select its category. We recommend that you copy the table and file data for the app when the new version has data structure changes. Then click Copy App. To work on the new app copy, click Customize your App, and make any desired changes. Then test the app with your test users. When the new app is ready for deployment, run a deployment check, fix any errors and warnings, and mark it as Deployed. We discussed how to deploy in Publisher app in a previous course in the series. Open the original app in the AppSheet editor and navigate to the Managed Versions tab. Expand the App Upgrade section and provide the name of the app copy to upgrade this app from. The app name is a unique name that includes a user ID suffix. You can find the app name in the URL of an app when you open it in the app editor. Enable the option to Create a New Major App Version, and click Upgrade App. After the app is upgraded, users will receive the new app version the next time they sync the app from their device. When upgrading your app, you should be aware of the following: As app users continue to use the existing version of your app, data updates could be made to the underlying data sources used by the app. These updates must be reconciled with a copy of the data sources that are used by the new, upgraded version of the app. To solve this issue, you can create a periodic process that reconciles the data between the two versions. AppSheet currently does not provide a mechanism to do this automatically. In addition, active app users could be using the current version of your app with cued data changes that have not yet been persisted in the underlying data source. If the upgraded version of your app includes changes to the data structures used by the app, some of the cued data changes might fail after the app is upgraded. For example, consider this sequence of events: The current version of your app contains a table with five columns. A user of this current version of your app has entered a new row via the app. The user hasn't explicitly synced this new row with the backend, or due to connectivity issues, this has not automatically occurred. At the same time, you upgrade the app in AppSheet to a new major version that includes two additional columns in the same table. When the user is online, or tries to sync the update, it will fail due to the mismatch in the table's data structure between the two app versions, and an error is displayed in the app. To help mitigate this app sync issue, two options can be used; App Recovery Mode, and Manual Recovery. App Recovery Mode -- placing the app in Recovery Mode allows the sync process to proceed on the device. The place your app in Recovery Mode, navigate to the Manage Deploy tab in the AppSheet editor, and click to Switch to Recovery Mode. Read the warning message, and click OK to proceed. The app user can then retry the sync on the device again. This time, it should go through successfully. In the Manage Deploy tab in the AppSheet editor, move the app back to Normal Mode by clicking Return to Normal Mode. A special Recovery folder is created within the root folder of the app, in the app owner's cloud file system. The folder contains Recovery.txt files that contain the data changes from the app. The app owner then examines the row values from these files and copies them to the app's data sources as appropriate. Manual Recovery -- with Manual Recovery, app users manually re-apply their data changes by following these steps: Use the Show Changes menu option in the app's main menu to view and email the data changes to themselves or the app owner. As before, this also creates a copy of the changes in a special Recovery folder in the root folder for the app in the app owner's cloud file system. Then the app user clicks the Reset Changes menu option to discard their changes made in the app. After the app user confirms the reset, AppSheet permanently discards the queued changes and synchronizes the app with the backend. The app owner than manually reapplies the data changes to the data source. As part of your app upgrade planning process, you should inform your app users that your app will be undergoing a major upgrade on a certain date, and that they should complete any data updates like ads, updates, deletes before that date. Try to upgrade the app at a time when the app is least used. Immediately after upgrading your app to a new major version, inform your users to sync the app on their devices to retrieve the upgraded version of your app. To restore your app to a previous version, follow these steps: Navigate to the Manage Versions tab in the AppSheet editor and click Get Version History to list the current and previous versions of your app. Determine the version you want to restore the app to, and click View. AppSheet opens that version of the app in Read Only Mode in a separate browser tab. To restore the app to this version, click Restore. After confirming the restore, AppSheet restores your app to the previous version.

### Video - [Monitoring your app](https://www.cloudskillsboost.google/course_templates/390/video/320456)

- [YouTube: Monitoring your app](https://www.youtube.com/watch?v=Aj7a9l8uXo0)

Person: It's always a best practice to monitor your app's performance, learn how users interact with your app and troubleshoot issues with your app when they arise. In this video, you'll learn how to monitor your app's usage and performance using the tools available in the AppSheet UI. AppSheet provides these capabilities in the Manage Monitor tab in the AppSheet UI. To view usage statistics for your app, navigate to the Manage Monitor tab in AppSheet UI. Click Usage Statistics to expand that section, and click Get Usage Statistics. AppSheet generates a set of charts that plot your app's usage statistics, which are total unique app users per month, total unique app users per day, count of app users per day and number of interactions per day by app user. You can use these charts to gauge the level of user interaction with your app. AppSheet provides an audit history log that records recent transactions in your app. The length of time that transactions are retained is based on your AppSheet subscription plan. We discussed the audit history features in the security module of this course, and we'll briefly review the topics here. To view your app's audit history, navigate to the Manage Monitor tab in the AppSheet UI. Expand the Audit History section, and click Launch Log Analyzer. This launches the Audit History Dashboard that contains recommendations to improve the performance of your app, charts that plot the count of operations and operations by user and details of each operation. You can also filter the audit history by date range, type of operation, table and user ID. You can use the audit history to troubleshoot sync issues between the app running on the user's device in the back end, AppSheet API calls, Zapier API calls and automation bot issues. To investigate sync and other issues, look for audit entries with the appropriate operation, for example, app sync. Click the icon in the details column for the table entry to view more details and the outcome of that operation. The details of the operation contains information in JSON format and can be used to determine if any errors may have occurred. AppSheet also maintains a performance profile for your app that is similar to the audit history log. For each sync, add, update and delete recorded by the AppSheet back end, detailed performance information is captured during the execution of the operation. To view your app's performance profile, navigate to the Manage Monitor tab in the AppSheet UI. Expand the Performance Profile section, and click Launch Performance Analyzer. This launches the Performance Analyzer Dashboard that contains recommendations to improve the performance of your app, a chart that plots the average duration for each type of operation and details of each operation. You can also filter the operations by date range, type of operation, table and user ID. To view the performance details of each operation, click the icon in the Performance column of the Operations table. The performance details include the time consumed by the operation and its child tasks including the details of each task. You can use this information to detect any long-running tasks of an operation and implement changes in the app to improve their performance. Examples of long-running tasks include synchronizing too many tables or those that have too much data, reading tables that might have too much data and evaluating complex virtual column expressions. You can improve the performance times of these operations by using partitioning and security filters for large tables, rewriting expressions used in your app to be more efficient ,and after making these changes in your app, you can use the Performance Analyzer Dashboard to continue monitoring the performance of the app.

### Video - [App authoring](https://www.cloudskillsboost.google/course_templates/390/video/320457)

- [YouTube: App authoring](https://www.youtube.com/watch?v=JbB6441KEbY)

Katelyn: During the life cycle of your app, you might need to hand off the app to someone else or collaborate with other people to implement app features. In this video, you will learn how to perform authoring functions for your app and how to collaborate with other team members to share data and develop your app. AppSheet provides these capabilities in the manage author tab of the AppSheet UI. In this tab, the plan requirements section enables you to understand the need for a specific AppSheet subscription plan based on the features used in your app. Click analyze app features. Based on the features currently in use by the app, this section lists the AppSheet subscription plans that can and cannot be used. The example shows that the AppSheet Enterprise plan, which includes the table partitioning and user sign-in features that are used by the app, is allowed. Details about the various subscription plans are available at the AppSheet documentation website. As an app creator, you can showcase your app samples and use your app portfolio to make them available to others. The apps in your portfolio are publicly visible samples. Other users can view or copy your portfolio apps and data, but they cannot modify them. The data in your portfolio apps is visible to the public, so never include confidential data in an app that will be part of your portfolio. To add an app to your portfolio, confirm that the app is deployed. Navigate to the manage author tab in the AppSheet UI. Click teamwork to expand the section. Enable the option to make the app a public sample and click change visibility to add the app to your portfolio. You must also provide a description for your app portfolio. Navigate to the my account collab tab in the AppSheet UI. Enter a portfolio description, click save and click view my app portfolio to view your portfolio. Please note that the portfolio page is publicly visible. The AppSheet UI gives you the ability to collaborate with other users on app development. If you're part of an app development team within an organization, you might need to collaborate with other team members to develop apps. To co-author an app with users, click the share app icon in the top panel of the AppSheet UI. Enter the email address of the user with whom you want to share your app and click enter. Enable the advanced option and then select one of the following app permissions for the user. View definition, with this permission, the user can view the app in the AppSheet Editor but can't edit the app. Or edit definition, with this permission, the user can view and edit the app in the AppSheet Editor. Optionally, you can send an email notification to the user to invite them to install and access your app. To send a notification, select notify users and modify the notification message as required. If required, change the authentication provider that is used for the user's sign-in process. Pass the captcha challenge and then click send or share if you did not opt to notify the user. Repeat these steps to share your app with additional users as needed. Consider the following when co-authoring an app with other users. If multiple users attempt to edit an app at the same time, conflicts might occur when the app is saved. AppSheet does not allow a co-author to add a table from the original app creator's cloud file system for security reasons. This is to prevent any inadvertent exposure of the app creator's entire cloud file system. AppSheet also does not allow a co-author to add a table from the co-author's cloud file system. AppSheet typically accesses the cloud data source using access tokens generated on behalf of the app creator. Allowing a co-author to add tables from their own cloud file system could lead to the situation where no single author could view and change all the app's data or investigate and fix problems with an app. AppSheet allows a co-author to add a new table to the app only from a team-shared data source. We discuss how to manage a team-shared data source in the next video in this module.

### Video - [Team collaboration](https://www.cloudskillsboost.google/course_templates/390/video/320458)

- [YouTube: Team collaboration](https://www.youtube.com/watch?v=TmH9mHCazPQ)

Katelyn: If you're an AppSheet account admin and part of an app development team within an organization, you can create a team to co-develop your app with other members. In this video, we discuss how you can define your team, manage your shared data and collaborate with other members to develop your app. A team is a group of AppSheet users who are all from your own organization. If your AppSheet account is from an organization, for example user@company.com, you can set up a team of users from your organization. To view a manager team in the AppSheet UI, click on the account icon in the top navigation pane and in the drop-down menu, click My Team. The My Team section in the AppSheet UI displays your team dashboard. In this dashboard, as an admin, you can create your team and track adoption. Click manage team to adopt users into an existing team based on a Workspace organization or Google Group. Or to define a new team, click adopt users to view and adopt users from the organization or group into the team. Click adopt users again to add the users to your team. After your team has been created, use the dashboard to invite members to create their AppSheet accounts and become app creators. Click invite member. Provide the member's e-mail addresses in the dialog and click invite. In the shared apps tab in the team dashboard, you can view and copy sample apps that have been shared by other team members. Simply click on the app that you want to copy, and in the new tab that opens the app, click copy and customize. You can also add your own app as a sample for your team members to view and use. They can leverage your experience and app design skills in their own apps. To add a sample app, click add a team sample. Then select the app that you want to add. AppSheet adds the app to the team samples section in the shared apps tab of the team dashboard. You can also add your app to the list of team samples in the dashboard. Navigate to the manage author tab in the AppSheet Editor. Expand the team work section. Enable the team sample option and click change visibility. To remove an app from the list of team or public sample apps, disable the corresponding options and click change visibility. The shared data tab in the team dashboard lists data sources that are shared with the team. The security tab of the team dashboard lists the authentication sources for each member of the team. The security and other tabs in the team dashboard are typically used by the IT admin group at an organization to view and manage security, billing and app usage. If the owner is part of a team that is configured with AppSheet's team collaboration capabilities, every team member can access and use data sources that are marked as team shared. A team-shared data source aims to achieve the following goals: enable collaboration on apps between co-authors and team members, ensure that data is retained independently of individual accounts, control who can directly access the data and minimize disruption when an app is transferred to a new owner. The steps to create a shared data source depend on the cloud data provider. Let's review how this is done using Google Drive. Create a shared drive. The shared drive will be used to store data used by your AppSheet apps. For team members who will create apps that store data in the shared drive, add them to the shared drive with the appropriate role. Create a folder in the shared drive that will contain the app's data. Set the default file storage location in AppSheet. AppSheet uses the default file storage location to create a folder to store files associated with an app. The location can be set for an individual user's account or for an individual app. To set the default file storage location for a user's account, navigate to the my account settings tab in the AppSheet UI. Set the default folder path to the folder location and click save. In the example, on Google Drive, we use the path team drive AppSheet apps app data that is under a shared drive named AppSheet apps, which the user's account has access to. When this user creates a new app, AppSheet uses this location to create a folder that will contain files associated with the app. Other team members that have access to this shared drive folder can access the app's data while co-authoring the app. You can also set the default file storage location for an individual app. Open the app in the AppSheet Editor. Navigate to the info properties tab. Expand the app properties section. Set the default app folder to a folder on Drive for the app and click save. In the example, we use the path AppSheet data that is under the My Drive folder of the user's Google Drive account. To move an existing app from the account's My Drive location to the shared drive location, follow these steps. Follow the previous process to update the app owner's default file storage location in AppSheet to the shared drive location. Open the app to be moved and navigate to the manage author tab in the AppSheet UI. Then click copy app. In the clone your app dialog, set the category, and then for save app to, select Google. Click copy app in the dialog. AppSheet creates a copy of the app definition and the associated data. The data is saved to the default storage location in the shared drive. To configure an account to use SharePoint with Microsoft Office 365 as the storage location, refer to the documentation on the AppSheet website. AppSheet apps can also be transferred between accounts. When you use a shared data source, transferring apps between accounts is easy and efficient and does not require migration of any data. To transfer an app from one account to another, sign into AppSheet using the original app owner's account. Open the app to be transferred in the AppSheet Editor. Navigate to the manage author tab and click to expand the transfer section. Enter the new owner's account ID and e-mail address. Both of these values are listed on the recipient's My Account page. By entering both pieces of information, you ensure that the app is transferred to the correct recipient. Click transfer ownership to give the recipient full ownership of the app. You must ensure that the recipient owner's account has access to the file, sheets, images, PDFs, et cetera and folders used by the app. If the recipient's account does not have access, the app will stop working the moment ownership is transferred. As the team administrator, you can also transfer all apps under a member's account to yourself or to another member. To transfer the apps, sign into AppSheet with your admin account. Navigate to the My Team Members tab in the AppSheet UI. Find the member whose apps you want to transfer. Click the member e-mail to expand the section. Click transfer app ownership. In the pop-up dialog, enter the account that the apps will be transferred to. This can be your own account or the account of any member of your team. Click transfer to transfer the apps. As an administrator, you can also transfer ownership of apps that are owned by a user account to another account within a team by using the AppSheet API. Details on using the API are on the AppSheet website.

### Quiz - [Quiz](https://www.cloudskillsboost.google/course_templates/390/quizzes/320459)

#### Quiz 1.

> [!important]
> **The stable version of an app is 1.000007, and its latest version is 1.000008. If the setting to control the rollout of the latest version is set to 5 percent in the AppSheet editor, which statement is correct for app users who are not already assigned an app version?**
>
> - [ ] Five percent of app users are assigned app version 1.000008, and 95% are assigned version 1.000007.
> - [ ] Five percent of app users are assigned app version 1.000007, and 95% are assigned version 1.000008.
> - [ ] It is currently not possible to control the rollout of the latest version of an app for a percentage of app users.

#### Quiz 2.

> [!important]
> **What steps should you take to upgrade an app to a new major version in AppSheet? Select three.**
>
> - [ ] Implement any changes in the current version of the app, and update its version number.
> - [ ] Make a copy of the app to be upgraded, and name it appropriately.
> - [ ] Implement any changes in a copy of the app, test the copy, and deploy it.
> - [ ] In the AppSheet editor, upgrade the app from the copy, and create a new major version  of the app.

#### Quiz 3.

> [!important]
> **What are the purposes of the stable version of an app in AppSheet? Select three.**
>
> - [ ] It can be used to assign specific app users to that version of the app.
> - [ ] It can be used to control the rollout of future app versions.
> - [ ] It is used to upgrade an app from its current version to a new major version number.
> - [ ] It allows an app creator to continue making and saving minor changes to an app without affecting users that use the stable version.

#### Quiz 4.

> [!important]
> **How often is the minor version number of an app updated in AppSheet?**
>
> - [ ] The minor version number of an app cannot be updated.
> - [ ] Every time an app creator saves changes to the app's definition
> - [ ] Over a configurable duration, if there are any saved changes to the app definition
> - [ ] Once a day, if there are any saved changes to the app definition

#### Quiz 5.

> [!important]
> **AppSheet enables team collaboration for app development. What steps should you take to create a team and co-author an app with other team members? Select three.**
>
> - [ ] Share the app with other team members, and assign appropriate app permissions.
> - [ ] Create and use a team-shared data source.
> - [ ] Transfer ownership of the app to a team member within your organization.
> - [ ] Create a team, and then invite members to create their AppSheet accounts and join the team.

### Video - [Module Review](https://www.cloudskillsboost.google/course_templates/390/video/320460)

- [YouTube: Module Review](https://www.youtube.com/watch?v=vYRf740eHWQ)

PERSON: Congratulations on completing this module on managing your app. Let's do a quick review. In this module, you learned about AppSheet versioning and how to set the stable version of your app. You learned how to upgrade your app to a major version and how to restore your app to a previous version. You also learned how to monitor your app's usage and performance using tools available in the AppSheet UI. We discussed how you can perform authoring functions in AppSheet and how to collaborate with other team members to share data and develop your app.

## Troubleshooting Your App

Troubleshoot errors and common problems with your app.

### Video - [Data, access and sync errors](https://www.cloudskillsboost.google/course_templates/390/video/320461)

- [YouTube: Data, access and sync errors](https://www.youtube.com/watch?v=UJZUFdiThzE)

Katelyn: Welcome to the module on troubleshooting your app. As you build your app in AppSheet, you may sometimes encounter errors or warnings in the AppSheet UI. These are indicators of problems with your app, data or other configuration. This module helps you understand why you may experience problems with your apps and what are some of the strategies you can use to troubleshoot and resolve these issues with your app. Let's first review some of the errors and warnings you may encounter as you build and run your app, why you may see these errors or warnings and how you can fix them. AppSheet automatically extracts the data structure from a spreadsheet or table when your app is generated. When AppSheet reads your spreadsheet, some errors, warnings and information messages may be reported to the app editor due to spreadsheet structure, switching spreadsheets or mismatch in the column structure. Let's review each of these in detail. Errors with spreadsheet structure typically occur when AppSheet cannot identify the table's column header. To resolve this error, make sure that nontabular data like charts or pictures are not in the first or leftmost worksheet tab in your spreadsheet. In worksheets with tabular data, make sure that the header columns are in the first row of the spreadsheet. When you switch to a different table or spreadsheet for your app, AppSheet tries to retain as much as possible of your existing app definition. However, if the new table or spreadsheet has a completely different column structure than the original one that was used when creating the app, you may see errors related to the new data structure. To resolve these errors, modify the relevant parts of the app definition to use the new table or spreadsheet. One of the most common errors or warnings seen during the app creation process is when app creators modify their tables or spreadsheets to add, remove or rename columns. Each time you do this and regenerate the table's column structure in AppSheet, you may see errors or warnings if the old column structure and new structure do not align. For example, deleting a column from your table or spreadsheet that is used in an app formula for another virtual column will result in an error. To resolve these types of errors, regenerate the table's column structure and modify your app definition to align with new data naming and structure where required. In this example, if the virtual column is no longer required, delete the column in the app definition. If it is still required, update its formula. AppSheet can experience errors when accessing, reading or writing data from any cloud storage provider. These errors are usually related to permissions, time-out or server errors related to the data being accessed. AppSheet may encounter a 401 authorization error when it does not have permission to act on behalf of the app creator or app user. The app creator or app user must allow AppSheet to access their data that is stored on the cloud provider. This is typically done when signing into AppSheet. This error occurs when AppSheet does not have permission to access the table or spreadsheet containing your app's data. Even though you, or the app creator or the app user may have granted AppSheet access, there may be permissions settings and individual files that may prevent AppSheet from accessing those files. This may occur possibly because you have set the access mode in the app to access the table as app user, and the app user does not have permissions to access the data on the cloud provider. As the app creator, you may have built the app using a shared spreadsheet and now no longer have permissions to access the file. To resolve this error, make sure the file or table has appropriate permissions set for the required level of access. This error usually occurs when the file containing your app's data is not found on the cloud provider system. A common reason for this error is that the file may have been moved, deleted or renamed. To resolve this error, make sure the file exists in the correct location on the cloud provider system. If you've renamed a connected worksheet, try reverting the name or reconnecting the worksheet to the app. This is an internal server error generated by the back-end cloud provider that may occur when AppSheet attempts to read or write data to your spreadsheet or database. This error is considered to be transient as AppSheet automatically retries the read or write request to the cloud provider. As discussed in a previous module, the AppSheet sync process reads and writes data to and from the AppSheet server, which in turn fetches and updates the data to and from the cloud provider. Let's review the errors that could occur during the sync process. The sync process can generate errors due to poor network connectivity. To resolve this error, the app user can retry the sync request once network connectivity is restored. On occasion, a sync request may take a long time to process, or there may be connectivity issues to the AppSheet server. The app user might resubmit the sync request while the previous sync is still in process. If the server detects that the user request is still being processed, it returns the warning, "A duplicate request is already in progress." This tells the user that the server is still processing their original sync request. The user should wait and later retry the sync request. The app owner can also check the performance history of the app in the AppSheet UI to determine why sync requests are taking longer to complete. This error may occur during the sync process and is caused by a 403 permissions error on the data file or spreadsheet being accessed by the app. The cause and resolution of this error is the same as discussed in the previous section. Make sure the file has the correct set of permissions for the level of access required. The sync process may return this error when synchronizing data changes made in the app. This error occurs when the AppSheet back end is unable to send your changes onto the cloud storage provider. Almost always, this is because the request timed out. If this error occurs often, it is usually due to complex cross-sheet formulas in the spreadsheet which take a lot of time to complete. To resolve this error, you may need to simplify your spreadsheet, in particular to avoid using some cross-sheet formulas. You may see this error when the app attempts to sync queued changes in the app after the app definition has been changed on the AppSheet server. Changes to the app definition can include table columns that were added or removed, thus causing the failure due to the sync process using the older data structure. The difference in app definitions can be verified by comparing the version numbers of the app on the user's device with that of the app in AppSheet. To resolve this error, use the Recovery Mode or Manual recovery feature as discussed in a previous module of this course. To check the version number of the app on the user's device, click the about menu item in the app's main menu. To check the version of the app in the AppSheet back end, open the app in the AppSheet Editor. Navigate to the info properties tab and click app properties to expand the section to view the version number. In this section, we review some general application errors that may occur in your app. This error is seen in the app emulator, in the AppSheet Editor or on the app user's device. The most likely cause for this error is that the app definition is invalid due to changes in the underlying table structure in the database or spreadsheet, making it incompatible with the app. In most cases, AppSheet will automatically adjust the app to make it runnable again when the app creator opens the app in the AppSheet Editor. To resolve this error manually, open the app in the AppSheet Editor to review and fix any errors reported in the info errors tab. Then update and save the app's definition and then redeploy the app. This error occurs for app users when the app creator has paused the app. Pausing an app prevents users from making any changes to the data via the app and synchronizing those changes. This is usually done for maintenance of your spreadsheets or databases during a limited time window. This error is resolved when the app creator has completed any maintenance updates and resumes the app in the AppSheet Editor. To pause or resume the app, open your app in the AppSheet Editor. Navigate to the manage deploy tab and click pause to pause the app or resume paused app to resume the app. This error occurs when there are one or more alerts on your account that are related to billing. If the alerts are not resolved within a period of time, the system blocks your app, and users will see an error message saying that the app is blocked. An app user may also see this error if they are signed in on their device with the wrong cloud provider account. To resolve the error, check the alerts that are shown in the My Account page and address them as quickly as possible. Also, make sure that the app user is using the correct account, personal versus work, to sign into AppSheet. Once all the alerts are addressed and no longer shown, users of your app will need to run the sync process once to fetch the latest app definition. Once this is done, the app functions as expected. AppSheet has also documented other errors you may encounter with specific cloud data providers. Please review the documentation on the AppSheet website.

### Video - [Troubleshooting common problems](https://www.cloudskillsboost.google/course_templates/390/video/320462)

- [YouTube: Troubleshooting common problems](https://www.youtube.com/watch?v=gXSBCJcPhXs)

Person: We've discussed the various types of errors that can occur with your app in the previous video, the causes of those errors and how you can resolve them. In this lesson, we look at some common problems that may occur with your app and what you can do to troubleshoot and fix them. When displaying images in your app, a common issue that occurs is that the images do not load in the app. In our sample app, as seen in the preview, some images are not available. AppSheet uses the exclamation icon to indicate this issue in the app. We discussed how images are stored and displayed in your app in a previous AppSheet course, but let's do a quick recap. Apps that display or capture images store a relative path to the image file on your cloud provider or a publicly accessible URL to the image file in a table column. Our sample app stores publicly accessible URLs to the image files in the image column of the projects table. If the app's images are stored in a folder on the cloud provider, the value in the tables column must be a relative path to the folder that contains the image files. The folder must be located relative to the location of your spreadsheet data that is used by the app. For apps that use database tables, the folder must be located within the app default folder on the cloud provider. To render the image in the app, AppSheet constructs an HTTPS URL to the image. The constructed URLs are different based on if you use images that are stored publicly or in a folder on your cloud provider. To troubleshoot the issue of images not displaying in your app, you should confirm that the value in the table column contains the correct URL or folder path location to the image file, copy the AppSheet constructed URL to the image and paste it in a separate tab in your browser to confirm that the browser can access and render the image directly. To obtain the image URL, open your app in the AppSheet editor. Navigate to the data tables tab. Expand the table that contains the image URLs or folder paths, and click view data. This opens a separate browser tab containing a partial set of rows from the table or spreadsheet. The image column will display a broken file icon with a link for the missing image. Click the link to open another browser tab with information about the error. This tab contains information about the error in the AppSheet-generated URL to the image in the browser's URL bar. You can check the image URL to determine how to correct it and then update the URL in the table. There are different reasons why data changes that are made in the app may not be recorded in the back-end database or spreadsheet. You can take the following actions to troubleshoot the issue. Check that the app is successfully synchronizing data changes with the AppSheet back end. We reviewed sync errors and how you can troubleshoot them in the previous lesson. Check the app's audit history log to see if the update, delete and sync operations were received and executed successfully. Click details for specific log entry to drill down and review any errors for that operation. We discussed AppSheet's audit history capability in a previous module of this course. A couple of other things to consider: Do not use the RowNumber column in a spreadsheet as the key of your table, as this can lead to data being overwritten or the wrong row being updated. AppSheet inserts new rows in a sheet after the last row. If you have a large number of empty rows in the middle of the sheet, you may not see the new entry unless you scroll down in the spreadsheet. It's a good practice to remove all empty rows from your spreadsheet. Let's review how you can investigate and resolve application crashes. If users of your app are experiencing app crashes on their device, you can instruct them to close any background apps that are consuming a lot of memory; reinstall the AppSheet hosting app on the device and clear the data used by the app; restart the device to make more system memory available; update the device's operating system since an update could resolve the issue; and make more storage space available on the device by removing unwanted apps, photos, videos, et cetera. The app might not function optimally when the device is low on storage. To get help and support for issues with your AppSheet app, you can add your app to your portfolio to allow other team members to troubleshoot your app, review AppSheet documentation, get help from the AppSheet community and contact AppSheet customer support.

### Quiz - [Quiz](https://www.cloudskillsboost.google/course_templates/390/quizzes/320463)

#### Quiz 1.

> [!important]
> **An image does not load or display in the app. What is the likely cause of this issue?**
>
> - [ ] The image is stored on a public cloud provider whose servers are down.
> - [ ] The relative folder path to the image file is incorrectly specified in the app's table.
> - [ ] The image file is too big.

#### Quiz 2.

> [!important]
> **What data- and access-related problems might be reported for your app in AppSheet? Select three.**
>
> - [ ] A 401 authorization error is reported in AppSheet.
> - [ ] AppSheet cannot identify a table's column headers.
> - [ ] A table's underlying data file or spreadsheet contains too many rows.
> - [ ] The column structure in the app's definition doesn't match the underlying table.

#### Quiz 3.

> [!important]
> **When the sync process attempts to update queued data changes from the app to the AppSheet server, an error report might indicate that the changes cannot be applied because the app definition (including table structure) has been changed on the AppSheet server. What are two ways to resolve this issue?**
>
> - [ ] Use manual recovery.
> - [ ] Use recovery mode.
> - [ ] Upgrade the user's version of the app to the latest version.
> - [ ] The user can wait for some time before retrying the sync process on their app.

### Video - [Module Review](https://www.cloudskillsboost.google/course_templates/390/video/320464)

- [YouTube: Module Review](https://www.youtube.com/watch?v=n6GbodVaqpA)

PERSON: Congratulations on completing this module on troubleshooting your app. Let's do a quick review. In this module, you learned about the different types of data, access, and sync errors that app creators and users may experience when creating or using an AppSheet app and how to resolve those errors. You also learned how to fix common problems that can occur while your app is used and how you can get support to troubleshoot your app.

## Course Review

Course review and knowledge gained from the course.

### Video - [Course Review](https://www.cloudskillsboost.google/course_templates/390/video/320465)

- [YouTube: Course Review](https://www.youtube.com/watch?v=xX58E1fm1SE)

Hansel: Congratulations on completing the implementation course on building no-code apps with AppSheet. Let's review what was discussed and how you can use the knowledge gained from this course. With the knowledge gained from this course, you can now effectively organize and manage your data used by your app, use AppSheet capabilities to control the display and the validity of your data, use AppSheet actions and UI behaviors to customize and enhance the user experience of your app, use AppSheet's security features to authenticate and authorize user access to your app and its data and protect sensitive information in your app, configure your app to run webhooks to external services and to the AppSheet API, use an Apigee REST API as a data source for your app and use the AppSheet API to integrate external applications with your app. Monitor and improve your app's scalability and performance with security filters and data partitions. Use AppSheet capabilities to control the language and locale of text and data used in your app and enable users to provide feedback about your app. Create different versions of your app with AppSheet's versioning capabilities to manage changes and upgrades to your app. Monitor your app's usage and use the audit history log to track app performance. Author and collaborate with your team on app development. Troubleshoot common problems and resolve various types of errors that might occur in your app. Now that you have completed the implementation course on building no-code apps with AppSheet, I encourage you to look for the next course in this series on AppSheet Automation. In the meantime, we recommend browsing the AppSheet documentation on the appsheet.com website and join the community at community.appsheet.com. Congratulations again on completing this course, and we wish you all the best on your learning journey with AppSheet.

## Your Next Steps

### Badge - [Course Badge](https://www.cloudskillsboost.googleNone)
